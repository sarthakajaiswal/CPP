======== 06 MARCH 2025 =========================================================================================================================================================

#include <iostream> 
#include <cstring> 
#include <vector> 

using std::cout;    // object of class ostream | ostream and cout are in namespace std 
using std::endl;    // endl is defined in std namespace 
using std::string;  // string is a class defined in std namespace (header -> string) 
using std::vector;  // vector is a 'class template' defined in std namespace (header -> vector) 

class Date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        void show(void) 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    // vector of ints 
    vector<int> ivec1; 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> ivec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100);  
}

vector<int> ivec1; 
vector<int> ivec2{10, 20, 30, 40, 50}; 
vector<int> ivec3(ivec2); 
vector<int> ivec4(5); 
vector<int> ivec5(4, 200); 

vector<int> ivec1; 
vector<int> ivec2{10, 20, 30, 40, 50}; 
vector<int> ivec3(ivec2); 
vector<int> ivec4(5); 
vector<int> ivec5(5, 100); 

vector<int> ivec1; 
vector<int> ivec2{10, 20, 30, 40, 50}; 
vector<int> ivec3(ivec2); 
vector<int> ivec4(5); 
vector<int> ivec5(5, 100); 

vector<int> ivec1; 
vector<int> ivec2{10, 20, 30, 40, 50}; 
vector<int> ivec3(ivec2); 
vector<int> ivec4(5); 
vector<int> ivec5(5, 100); 

vector vector vector vector vector vector vector vector vector vector vecot r vecot rvecrore vector vector vector vector vector vector vector vector vector vector vector vecator vector vector vector vvector vector vector 
vector vector vector vector vector vector vector vector vector vector vecetor vector vector vector vector vector vecotr vecot vector vectoe vecotvector vector vector lvecot<int> 
vvector<int> vectot<int> 
vector<int> vector<iont?> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> 
vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> 
vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vetor<int> vector<int> vector<int> vector<int> 
vector<int> vector<int> vecator<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> 
vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> vector<int> 

vector<float> vector<float> vector<float> vector<float vector<float> vector<float> vector<float> vector<float vetor<float> 
vector<double> vector<double> vector<double> vector<double> vecot<deouble> vector<double> vector<double> vecotr<deouble> 
vetor<Date> vector<Date> vector<Date> vector<Date> vector<Date> vector<Date> vectir<Date> vector<Date> vector<Date> vector<Date> 
vector<char> vector<char> vector<char> vector<char> vector<char> vector<char> vector<char> vector<char> vector<char> vector<char> 

#include <iostream> 
#include <string> 
#include <vector> 

using std::endl;    // endl is in std namespace 
using std::cout;    // cout is a object of class ostream | cuot and ostream are in std namespace 
using std::string;  // string is a class (header -> string) 
using std::vector;  // vector is a class template (header -> vector) 

class Date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    vector<int> ivec1; 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> ivec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100); 
}

#include <iostream> 
#include <vector> 
#include <string> 

using std::cout;    // cout is a object of class ostream | class ostream and its object cout are in std namesoace 
using std::endl;    // endl is defined in std namesoace 
using std::vector;  // vector is a class template defined in std namespace (header -> vector) 
using std::string;  // string is a class defined in std namespace (geder -> string) 

class Date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    vector<int> ivec1; 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> ivec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100); 
}

#include <iostream> 
#include <string> 
#include <vector> 

using std::cout;    // cout is a object of class ostream | class ostream and its object cout are in std namespace 
using std::endl;    // endl is defined in std namespace 
using std::string;  // string is a class defined in std namespace (header -> string) 
using std::vector;  // vector is a class template defined in std namespace (header -> vector) 

class Date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            day = init_day; 
            month  = init_month; 
            year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    vector<int> ivec1; 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> vec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100); 
}

#include <iostream> 
#include <string> 
#include <vector> 

using std::cout;    // cout is a object of class ostream | object cout and class ostream are defined in std namespace 
using std::endl;    // endl is defined in std namespace 
using std::string;  // string is a class defined in std namespace (heder -> string) 
using std::vector;  // vector is a class template defined in std namespace (header -> vector) 

class Date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        } 

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    vector<int> ivec1; 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> ivec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100); 
}

//------------------------------------------------------------

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_demo(void); 
void vector_demo(void); 

int main(void) 
{
    string_demo(); 
    vector_demo(); 

    return (0); 
}

void string_demo(void) 
{
    string s1; 
    string s2("Hello"); 
    string s3(s2); 

    cout << "--------STRING DEMO ENTER----------" << endl; 
    cout << "s1: " << s1 << endl;   // empty 
    cout << "s2: " << s2 << endl;   // hello 
    cout << "s3: " << s3 << endl;   // hello 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 
    cout << "Contents of s1 and s2 are same but the addressess are not " << endl    
            << "this proves that s2 is a clone of s2" << endl; 

    cout << "Show string char by char : " << endl; 
    cout << "METHOD 1: Using index : " << endl; 

    for(string::size_type i = 0; i != s2.size(); ++i) 
        cout << "s2[" << i << "] = " << s2[i] << endl; 
    cout << "---------- METHOD 1 END ------------" << endl; 

    cout << "METHOD 2 : Using iterator : " << endl; 
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter)
        cout << "*iter = " << *iter << endl;  
    cout << "------ Method 2 End -----------" << endl; 
    cout << "------ STRING DEMO LEAVE ----------" << endl; 
}

//  string -> dynamically resizable array of characters 

void vector_demo() 
{

}

namespace std 
{
    class string 
    {
        public : 
            typedef unsigned long long size_type; 
    }; 
}; 

#include <string> 

int main(void) 
{
    std::string::size_type i; 
}

// with using std::string 
#include <string> 
using std::string; 

int main(void) 
{
    for(string::size_type i) 
}

namespace std 
{
    class string 
    {
        public: 
            typedef unsigned short size_type; 
    }
}

s2.fun();  // std::string::fun(&s2); 

namespace std 
{
    class string 
    {
        public: 
            typedef unsigned long long size_type; 

            size_type size() 
            {
                // return length of the string pointed by this  
            }
    }
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_demo(void); 

int main(void) 
{
    string_demo(); 

    return (0); 
}

void string_demo(void) 
{   
    string s1; 
    string s2("Hello"); 
    string s3(s2); 
    
    cout << "-------- STRING DEMO BEGIN ----------" <<endl; 
    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 
    cout << "Contents of s2 and s3 are same but the addressedd are differene " << endl 
            << "This proves s3 is a clone of s2." << endl; 

    cout << "Show a string char by char : " << endl; 
    cout << "Method 1: using index" << endl; 

    for(string::size_type i = 0; i != s2.size(); ++i) 
        cout << "s2[" << i << "] = " << s2[i] << endl; 
    cout << "------------- METHOD 1 END ---------------" << endl; 

    cout << "METHOD 2 : Using iterator " << endl; 
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 
    cout << "-------- METHOD 2 END --------" << endl; 
    cout << "---------- STRING DEMO LEAVE ----------" << endl; 
}

#include <iostream> 
#include <string> 
#include <vector> 
 
using std::endl; 
using std::cout; 
using std::vector; 

void string_demo(void); 

int main(void) 
{
    string_demo(); 

    return (0); 
}

void string_demo(void) 
{
    string s1; 
    string s2("Hello"); 
    string s3(s2); 

    cout << "-------- STRING DEMO START ------" << endl; 
    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 
    cout << "Address of s2 and s3 are different while contents are same" << endl 
            << "This proves s3 is a clone of s2" << endl; 
    
    cout << "Showing string char by char : " << endl; 
    cout << "METHOD 1: Using index : " << endl; 

    for(string::size_type i = 0; i != s2.size(); ++i) 
        cout << "s2[" << i << "] = " << s2[i] << endl; 
    cout << "------ METHOD 1 END" << endl; 

    cout << "METHOD 2 : using iterator" << endl; 
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter)
        cout << "*iter = " << *iter << endl; 
    cout << "Method 2 END" << endl; 
    cout << "----------- STRING DEMO LEAVE -------------" << endl; 
}

#include <iostream> 
#include <string> 
#include <vector> 

using std::cout; 
using std::endl; 
using std::vector; 

void string_demo(void); 

int main(void) 
{
    string_demo(); 
    return 0; 
}

void string_demo(void) 
{
    string s1; 
    string s2("Hello"); 
    string s3(s2); 

    cout << "-------- STRING DEMO ENTER -----------" << endl; 
    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl ; 
    cout << "addr(s3) : " << &s3 << endl; 

    cout << "Addresses of s2 and s3 are different while values are same" << endl 
            << "This proves s3 is a clone of s2" << endl; 

    cout << "Showing a string char by char " << endl; 
    cout << "METHOD 1 : using index" << endl; 

    for(string::size_type i = 0; i != s2.size(); ++i) 
        cout << "s2[" << i << "] = " << s2[i] << endl; 
    cout << "------- METHOD 1 END --------" << endl; 

    cout << "METHOD 2: Using iterator : " << endl; 
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 
    cout << "--------- METHOD 2 END ----------" << endl; 
    cout << "--------- STRING DEMO LEAVE ----------" << endl << endl; 
}

#include <iostream> 
#include <string> 

using std::endl; 
using std::cout; 
using std::string; 

void string_demo(void); 

int main(void) 
{
    string_demo(); 
    return (0); 
}

void string_demo(void) 
{
    string s1; 
    string s2("Hello"); 
    string s3(s2); 

    cout << "------ STRING DEMO ENTER -----------" << endl; 
    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 
    cout << "Contents of s2 and s3 are same but addressess are not" << endl 
            << "This proves s3 is a clone of s2" << endl; 

    cout << "Show a string char by char : " << endl; 
    cout << "METHOD 1: Using Index" << endl; 
    for(string::size_type i = 0; i != s2.size(); ++i) 
        cout << "s2[" << i << "] = " << s2[i] << endl; 
    cout << "-------- METHOD 1 END -------" << endl; 

    cout << "METHOD 2 : Using iterator" << endl; 
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 
    cout << "--- METHOD 2 END -------" << endl; 
    cout << "----------- STRING DEMO LEAVE ------------" << endl; 
}   

#include <iostream> 
#include <string> 

using std::endl; 
using std::cout; 
using std::string; 

void string_demo(void); 

int main(void) 
{
    string_demo(); 
    return 0; 
}

void string_demo(void) 
{
    string s1; 
    string s2("Hello"); 
    string s3(s2); 

    cout << "--------------------- STRING DEMO ENTER --------------" << endl; 
    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 
    cout << "contents of s2 and s3 are same but addressess are not" << endl 
            << "This proves that s3 is a clone of s2" << endl; 

    cout << "show a string char by char : " << endl; 
    cout << "METHOD 1 : Using index" << endl; 

    for(string::size_type i = 0; i != s2.size(); ++i) 
        cout << "s2[" << i << "] = " << s2[i] << endl; 
    cout << "----------- METHOD 1 END ----------" << endl; 
    
    cout << "METHOD 2 : Using iterator " << endl; 
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 
    cout << "---------- METHOD 2 END ----------" << endl; 
    cout << "--------------------------- STRING DEMO LEAVE -------------" << endl; 
}

int p; 

int main(void) 
{
    int i;  // definition point 

    for() 
    {
        // i in main() is accessible
        for() 
        {
            int k; 
            // i in main() is accessible 
            // k is accessible 
        }
        // k is not accessble here 
    }
    // k is not accessible here 
}

void f(void) 
{
    // i in main() is not accessible 
}

class Date 
{
    public: 
        typedef int day_t; 

        static void test() 
        {

        }

        class XYZ 
        {} 
}

#include <iostream> 

using std::cout; 
using std::endl; 

namespace X 
{
    // data variable inside namespace 
    int num; 

    // function variable inside namespace 
    void test() 
    {
        cout << "Hello world" << endl; 
    }

    // class inside namespace 
    class Date 
    {
        private: 
            int day, month, year; 
        public: 
            Date() 
            {
                day = 1; 
                month = 1; 
                year = 1970; 
            }
    }; 

    // typedef inside namespace 
    typedef int xyz_t; 

    // namesoace inside namespace 
    namespace Y 
    {
        int p; 
    } 
}; 

class Test 
{
    public: 
        int num;            // data member  
        static int snum;    // static data member 

        // member function 
        void test_function() 
        {
            cout << "Inside test()" << endl; 
        }

        // statuc member function 
        static void stest_function() 
        {
            cout << "Inside static test() " << endl; 
        }

        // typedef 
        typedef int pqr_t; 

        // class 
        class PQR 
        {
            private: 
                int p, q, r; 
        }
}; 

// definition of static variable snum inside class Test 
int Test::snum = 100; 

========================================== 07 MARCH 2025 =====================================================

namespace X 
{
    // class in namespace 
    class MyClass 
    {
        private: 
            int day, month, year; 
        public: 
            Date() 
            {
                day = 1; 
                month = 1; 
                year = 1976; 
            }
    }; 
    
    // data variable 
    int num; 

    // function variable 
    int fun(void) 
    {
        return (10); 
    }

    // namespace 
    namespace Y 
    {} 
}

class Date 
{
    private: 
        int day; 
        int month; 
        static int year; 
    public: 
        // static member function 
        static void test() 
        {

        }

        int get_day() 
        {

        }

        typedef int day_t; 

        class XYZ 
        {};  
}

class Date 
{
    private: 
        int day; // non-static data member 
        int month;  // non-static data member 
        static int year; // static data member 
    public: 
        // static function member 
        static void test() {

        }

        // non-static member function 
        void test2(void) {

        }

        // typedef 
        typedef int day_t; 

        // class 
        class XYZ 
        {}; 
}

inside class we can have 6 kind of entities 
1) static data member 
2) non-static data member 
3) member function 
4) static member function 
5) typedefs  
6) class 

//-------

#include <iostream> 

using std::cout; 
using std::endl; 

// Namespace : It is a block for creating new names 
// Inside namespace X we have defined following names 
// num, test, Date, xyz_t, Y 
namespace X{
    // data variable names 
    int num; 

    // function inside namespace 
    void test() {
        cout << "Hello World!" << endl; 
    }

    // class inside namespace 
    class Date 
    {
        private: 
            int day, month, year; 
        public: 
            Date() 
            {
                day = 1; 
                month = 1; 
                year = 1976; 
            } 
    }; 

    // typedef inside namespace 
    typedef int xyz_t; 

    // namespace inside namespace 
    namespace Y{
        int p; 
    }
}

class Test 
{
    public: 
        int num;    // data member 
        static int snum; // static data memeber 

        // member function 
        void fun() {
            cout << "Inside test() " << endl; 
        }

        // static member function 
        static void stest_function() 
        {
            cout << "Inside static test() " << endl; 
        }

        // typedef 
        typedef int pqr_t; 

        // class 
        class PQR 
        {
            private: 
                int p, q, r; 
        }; 
}; 

// definition of static variable snum inside class Test 
int Test::snum = 100; 

void namespace_demo(void); 
void class_demo(void); 

int main(void) 
{
    namespace_demo(); 
    class_demo(); 

    return 0; 
}

void namesoace_demo(void) 
{
    X::num = 200; // ok 
    X::test(); // ok 
    X::Date myDate; // ok 
    X::xyz_t my_num = 100; // ok 
    X::Y::p = 10; 
}

void class_demo(void) 
{
    // Test::num; // not allowed 
    // Test::test_function // Not allowed 

    Test::snum = 300; 
    Test::stest_function(); 
    Test::pqr_t my_num = 199; 
    Test::PQR my_object; 
} 

#include <iostream> 

using std::cout; 
using std::endl; 

namespace X 
{
    // data member 
    int num; 

    // function variable 
    void test() {
        cout << "inside X::test() " << endl; 
    }

    // typedef 
    typedef int xyz_t; 

    // class 
    class Date 
    {
        private: 
            int day, month, year; 
    }; 

    // namespace 
    namespace Y {
        int p; 
    }
}

class Test {
    public: 
        int num; // data member 
        static int snum; // static data member 

        // member function 
        void test_function() 
        {
            cout << "Inside test() " << endl; 
        }

        // static member function 
        static void stest_function() 
        {
            cout << "Inside static test()" << endl; 
        }

        // typedef 
        typedef int pqr_t; 

        // class 
        class PQR 
        {
            private: 
                int p, q, r; 
        }; 
}; 

// definition of static data member inside class 
int Test::num = 100; 

void namespace_demo(void); 
void class_demo(void); 

int main(void) 
{
    namespace_demo(); 

    return 0; 
}

void namespace_demo(void) 
{
    X::num; 
    X::fun(); 
    X::Date myDate; 
    X::xyz_t num; 
    X::Y::p = 1000; 
}

void class_demo(void) 
{
    // Test::num; // invalid 
    // Test::fun() // invalid 

    Test::stest = 10; 
    Test::stest_function(); 
    Test::pqr_t num = 10; 
    Test::PQR myObject; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Test 
{
    public: 
        int num; // non-static data member 
        static int snum; 

        // member function 
        void test() {
            cout << "Inside test() " << endl; 
        }

        static void stest_function() {
            cout << "Inside static test() " << endl; 
        }

        // typedef 
        typedef int pqr_t; 

        // class 
        class PQR 
        {
            private: 
                int p, q, r; 
        }; 
}; 

// definition of static data variable inside class 
int Test::snum = 100; 

namespace X 
{
    // data member 
    int num; 

    // function member 
    void fun(void) {
        cout << "Hello World!" << endl; 
    }

    // class inside namespace 
    class Date 
    {
        private: 
            int day, month, year; 
        public: 
            Date() {
                day = 1; 
                month = 1; 
                year = 1970; 
            }
    }; 

    // typedef inside namespace 
    typedef int day_t; 

    // namespace inside namespace 
    namespace Y {
        int p; 
    }
}

void class_demo(void); 
void namespace_demo(void); 

int main(void) 
{
    class_demo(); 
    namespace_demo(); 

    return 0; 
}

void class_demo(void) 
{
    // Test::num; // NOT ALLOWED 
    // Test::test(); // NOT ALLOWED 

    Test::snum = 100; 
    Test::stest_function(); 
    Test::pqr_t num = 100; 
    Test::PQR myObj; 
}

void namespace_demo(void) 
{
    X::num = 10; 
    X::fun(); 
    X::pqr_t var = 10; 
    X::Date date; 
    X::Y::p = 1000; 
}

void test_func_1() 
{
    outer_loop: 
    for(int i = 0; i < 5; i++) 
    {
        inner_loop: 
        for(int j = 0; j < 5; j++) 
        {
            if(cond) 
                goto outer_loop; // HIGHLY UNDESIRABLE UNTIL YOU ARE WRITTING A VERY LOW LEVEL CODE 
        }
    }
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

int main(void) 
{
    string s2("ABCDE"); 
    string::iterator iter = s2.begin(); 

    cout << "*iter = " << iter << endl; // *iter = 'A' 

    ++iter; // advance internal current pointer to next char (method 1) 
    cout << "*iter = " << *iter << endl; // *iter = 'B'; 

    iter++; // advance internal current pointer to next char (method 2) 
    cout << "*iter = " << *iter << endl; // *iter = 'C'; 

    // advance internal current pointer (method 3) 
    iter = iter + 1; 
    cout << "*iter = " << *iter << endl; // *iter = 'D' 

    iter = s2.begin(); 
    while(iter != s2.end()) 
    {
        cout << "*iter = " << *iter << endl; 
        ++iter; 
    }

    return 0; 
}

#include <iostream> 
#include <string> 

using std::endl; 
using std::cout; 
using std::string; 

int main(void) 
{
    string s2("ABCDE"); 
    string::iterator iter = s2.begin(); 

    cout << "*iter = " << *iter << endl; // *iter = 'A' 

    ++iter; // Advance iter to next char(method 1) 
    cout << "*iter = " << *iter << endl; // *iter = 'B' 

    iter++; // Advance iter to next pointer (method 2) 
    cout << "*iter = " << *iter << endl; // *iter = 'C' 

    // advance pointer to next char (method 3) 
    iter = iter + 1; 
    cout << "*iter = " << *iter << endl; // *iter = 'D' 

    iter = s2.begin(); 
    while(iter != s2.end()) 
    {
        cout << "*iter = " << *iter << endl; 
        ++iter;  
    }

    return 0; 
}

#include <iostream> 
#include <string> 

using std::endl; 
using std::cout; 
using std::string; 

int main(void) 
{
    string s2("ABCDE"); 
    string::iterator iter = s2.begin(); 

    cout << "*iter = " << *iter << endl; // *iter = 'A'

    ++iter; // advance internal current pointer to next char (method 1) 
    cout << "*iter = " << *iter << endl; // *iter = 'B' 

    iter++; // advance internal current pointer to next char (method 2) 
    cout << "*iter = " << *iter << endl; // *iter = c; 

    // advance current pointer to next char (method 3) 
    iter = iter + 1; 
    cout << "*iter = " << *iter << endl; // *iter = 'D' 

    iter = s2.begin(); 
    while(iter != s2.end()) 
    {
        cout << "*iter = " << *iter << endl; 
        ++iter; 
    }

    return 0; 
}

#include <iostream> 
#include <string> 

using std::endl; 
using std::cout; 
using std::string; 

int main(void) 
{
    string s2("ABCDE"); 
    string::iterator iter = s2.begin(); 

    cout << "*iter = " << *iter << endl; // *iter = A 

    ++iter; // advance internal current pointer to next char (method 1) 
    cout << "*iter = " << *iter << endl; // *iter = B 

    iter++; // advance internal current pointer to next char (method 2) 
    cout << "*iter = " << *iter << endl; // *iter = C 

    iter = iter + 1; // advance internal current pointer to next char (method 3) 
    cout << "*iter = " << *iter << endl; 

    iter = s2.begin(); 
    while(iter != s2.end()) 
    {
        cout << "*iter = " << *iter << endl; 
        ++iter; 
    }

    return 0; 
}

#include <iostream> 
#include <string> 

using std::endl; 
using std::cout; 
using std::string; 

void string_iterator_demo(void); 

int main(void)
{
	string_iterator_demo(); 
	return 0; 
}

void string_iteratot_demo(void)
{
	string s("ABCDE"); 

	// 1: using iterator and while loop 
	cout << "Repeat 1 : " << endl; 
	string::iterator my_iter = s.begin(); 
	while (my_iter != s.end())
	{
		cout << "*iter = " << *iter << endl; 
		++my_iter; // pre-increment 
	}

	// 2 : using iterator and while loop 
	cout << "Repeat 2 : using iterator and while loop : " << endl; 
	string::iterator iter_1 = s.begin(); 
	while (iter_1 != s.end())
	{
		cout << "*iter_1 = " << *iter_1 << endl; 
		iter_1++; 
	}

	// 3: Using iterator and while loop 
	cout << "Repeat 3 : Using iterator and while loop" << endl; 
	string::iterator iter_of_s = s.begin(); 
	while (iter_of_s != s.end())
	{
		cout << "*iter_of_s = " << *iter_of_s << end; 
		iter = iter + 1; // addition by 1 
	}

	// 1 for loop 
	cout << "Repeat 1 using for loop : " << endl; 
	for (string::iterator iter_2 = s.begin(); iter_2 != s.end(); ++iter)
	{
		cout << "*iter_2 = " << *iter_2 << endl; 
	}
	// iter_2 not available here 

	// 2 for loop 
	cout << "Repeat 2 using for loop " << endl; 
	for (string::iterator iterOfString = s.begin(); iterOfString != s.end(); iterOfString++
	{
		cout << "*iterOfString = " << *iterOfString << endl; 
	}

	// 3 for loop 
	cout << "Repeat 3 using for loop : " << endl;
	string strNameOfAcademy("CoreCode Programming Academy");
	for (
		string::iterator iterStr = strNameOfAcademy.begin();
		iterStr != strNameOfAcademy.end();
		iterStr = iterStr + 1;
	)
		cout << "*iterStr = " << *iterStr << endl; 
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_iterator_demo(void); 

int main(void)
{
	string_iterator_demo(); 

	return 0; 
}

void string_iterator_demo(void)
{
	string s("ABCDE"); 

	// Method 1 : Using while loop and iterator 
	cout << "Repeat 1 : " << endl; 
	string::iterator iter_1 = s.begin(); 
	while (iter_1 != s.end())
	{
		cout << "*iter_1 = " << *iter_1 << endl;
		++iter_1; 
	}

	// Method 2 : Using iterator and while loop 
	cout << "Repeat 2 : " << endl; 
	string::iterator iter_2 = s.begin(); 
	while (iter_2 != s.end())
	{
		cout << "*iter_2 = " << *iter_2 << endl; 
		iter_2++; 
	}

	// Method 3 : Using iterator and while loop 
	cout << "Repeat 3 : " << endl; 
	string::iterator iter_3 = s.begin(); 
	while (iter_3 != s.end())
	{
		cout << "*iter_3 = " << *iter_3 << endl; 
		iter_3 = iter_3 + 1; 
	}

	// 1 : for loop 
	cout << "Repeat 1 : using iterator and for loop " << endl; 
	for (string::iterator iter = s.begin(); iter != s.end(); ++iter)
	{
		cout << "*iter = " << *iter << endl; 
	}
	// iter is NOT avaiable here 

	// 2 for loop 
	cout << "Repeat 2 : using iterator and for loop : " << endl; 
	for (string::iterator iterOfString = s.begin(); iterOfString != s.end(); iterOfString++)
	{
		cout << "*iterOfString = " << *iterOfString << endl; 
	}

	// 3 for loop 
	cout << "Repeat 3 using for loop : " << endl; 
	string strNameOfAcademy("CoreCode Programming Academy"); 
	for (
		string::iterator iterStr = strNameOfAcademy.begin();
		iterStr != strNameOfAcademy.end();
		++iterStr;
		)
		cout << "*iterOfStr = " << *iterOfStr << endl; 
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_iterator_demo(void); 

int main(void)
{
	string_iterator_demo(); 

	return 0; 
}

void string_iterator_demo(void)
{
	string s("ABCDE"); 

	// 1: using iterator and while loop 
	cout << "Repeat 1: " << endl; 
	string::iterator my_iter = s.begin(); 
	while (my_iter != s.end())
	{
		cout << "Current char : " << *iter << endl; 
		++my_iter; // pre-increment 
	}

	// 2 : using iterator and while loop 
	cout << "Repeat 2: " << endl; 
	string::iterator iter_2 = s.begin(); 
	while (iter_2 != s.end())
	{
		cout << "current char : " << *iter_2 << endl; 
		iter_2++; // post increament 
	}

	// 3 : using while loop and iterator 
	cout << "Repeat 3 : " << endl; 
	string::iterator iter_of_s = s.begin(); 
	while (iter_of_s != s.end())
	{
		cout << "*iter_of_s = " << *iter_of_s << endl; 
		iter_of_s = iter_of_s + 1; // addition by 1 
	}

	// 1 for loop 
	cout << "Repeat 1 : using for loop" << endl; 
	for (string::iterator iter_1 = s.begin(); iter_1 != s.end(); ++iter_1)
	{
		cout << "*iter_1 = " << *iter_1 << endl; 
	}
	// iter_1 is not available here 

	// 2 for loop 
	cout << "Repeat 2 : Using for loop and iterator " << endl; 
	for (string::iterator iterOfString = s.begin(); iterOfString != s.end(); iterOfString++)
	{
		cout << "*iterOfString = " << *iterOfString << endl; 
	}

	// 3 for loop 
	cout << "Repeat 3 : Using for loop and iterator : " << endl; 
	string strNameOfAcademy("CoreCode Programming Academy"); 
	for (
		string::iterator iterStr = strNameOfAcademy.begin();
		iterStr != strNameOfAcademy.end();
		strNameOfAcademy = strNameOfAcademy + 1
	) {
		cout << "*iterStr = " << *iterStr << endl; 
	}
}

#include <iostream> 
#include <string>

using std::cout; 
using std::endl; 
using std::string; 

void string_iterator_demo(void); 

int main(void)
{
	string_iterator_demo(); 

	return 0; 
}

void string_iterator_demo(void)
{
	string s("Hello"); 

	// Repeat 1: using while loop and iterator 
	cout << "Repeat 1: Using while loop and iterator " << endl; 
	string::iterator iter_1 = s.begin(); 
	while (iter_1 != s.end())
	{
		cout << "current char = " << *iter_1 << endl; 
		++iter_1; // pre-increment operator 
	}

	// Repeat 2 : using while loop and iterator 
	cout << "Repeat 2 : Using for loop and iterator" << endl; 
	string::iterator iter_2 = s.begin(); 
	while (iter_2 != s.end())
	{
		cout << "Current char = " << *iter_2 << endl; 
		iter_2++; // post increament 
	}

	// Repeat 3 : Using for loop and iterator 
	cout << "Repeat 3 : Using while loop and iterator" << endl; 
	string::iterator iter_3 = s.begin(); 
	while (iter_3 != s.end())
	{
		cout << "Current char = " << *iter_3 << endl; 
		iter_3 = iter_3 + 1; // addition by 1 
	}

	// 1 for loop 
	cout << "Repeat 1 : Using for loop and iterator" << endl; 
	for (string::iterator iter = s.begin(); iter != s.end(); ++iter)
	{
		cout << "*iter = " << *iter << endl; 
	}
	// *iter not available here 

	// 2 for loop 
	cout << "Repeat 2 : Using for loop and iterator " << endl; 
	for (string::iterator iter = s.begin(); iter != s.end(); iter++)
	{
		cout << "*iter = " << *iter << endl; 
	}

	// 3 for loop 
	cout << "Repeat 3 : Using for loop and iterator" << endl; 
	string strNameOfAcademy("CoreCode Progarmming Academy"); 
	for (
		string::iterator iterStr = strNameOfAcademy.begin();
		iterStr != strNameOfAcademy.end();
		++iterStr
		)
	{
		cout << "*iterStr = " << *iterStr << endl; 
	}
}

#include <iostream> 
#include <string> 

using std::endl; 
using std::cout; 
using std::string; 

void string_iterator_demo(void); 

int main(void)
{
	string_iterator_demo(); 
	return 0; 
}

void string_iterator_demo(void)
{
	string s("Hell0"); 

	// Method 1: using while loop and iterator 
	cout << "Repeat 1: using while loop and iterator " << endl; 
	string::iterator iter_1 = s.begin(); 
	while (iter_1 != s.end())
	{
		cout << "Current char = " << *iter_1 << endl; 
		++iter_1; // pre increament 
	}

	// Method 2 : Using while loop and iterator 
	cout << "Method 2 : Using while loop and iterator " << endl; 
	string::iterator iter_2 = s.begin(); 
	while (iter_2 != s.end())
	{
		cout << "Current char = " << *iter_2 << endl; 
		iter_2++; // post increament 
	}

	// Method 3 : using while loop and iterator 
	cout << "Repeat 3 : Using while loop and iterator" << endl; 
	string::iterator iter_3 = s.begin(); 
	while (iter_3 != s.end())
	{
		cout << "*iter_3 = " << *iter_3 << endl; 
		iter_3 = iter_3 + 1; 
	}

	// 1 for loop 
	cout << "Repeat 1 : Using for loop and iterator " << endl; 
	for (string::iterator iter = s.begin(); iter != s.end(); ++iter)
	{
		cout << "*iter = " << *iter << endl; 
	}
	// iter is not avaialable here 

	// 2 for loop 
	cout << "Repeat 2 : Using for loop and iterator " << endl; 
	for (string::iterator iterStr = s.begin(); iterStr != s.end(); iterStr++)
	{
		cout << "*iterstr = " << *iterStr << endl; 
	}

	// 3 for loop 
	cout << "Repeat 3: Using for loop and iterator" << endl; 
	string strNameOfAcademy("CoreCode Programming Academy"); 
	for (
		string::iterator iterString = strNameOfAcademy.begin();
		iterString != strNameOfAcademy.end();
		++iterString
		)
	{
		cout << "*iterString = " << *iterString << endl; 
	}
}

#include <iostream> 

using std::cout; 

class Date 
{
    public: 
        typedef int day_t; 
        typedef int month_t; 
        typedef int year_t; 
    private: 
        day_t day; 
        month_t month; 
        year_t year; 
    public: 
        Date(day_t init_day, month_t init_month, year_t init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        day_t get_day() {
            return day; 
        }

        month_t get_month() {
            return month; 
        }

        year_t get_year() {
            return year; 
        }
}; 

int main(void) 
{
    Date myDate(15, 2, , 2025); 
    Date::day_t day = myDate.get_day(); // Date::get_day(&myDate) 
    Date::month_t month = myDate.get_month(); // Date::get_month(&myDate) 
    Date::year_t year = myDate.get_year(); // Date::get_year(&myDate) 

    cout << day << "/" << month << "/" << year << endl; 

    return (0); 
}

#include <iostream> 

using std::cout; 

class Date 
{
    public:     
        typedef int day_t; 
        typedef int month_t; 
        typedef int year_t; 
    private: 
        day_t day; 
        month_t month; 
        year_t year; 
    public: 
        Date(day_t init_day, month_t init_month, year_t init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        day_t get_day() {
            return day; 
        }

        month_t get_month() {
            return month; 
        }

        year_t get_year() {
            return year; 
        }
}; 

int main(void) 
{
    Date myDate(1, 1, 1970); 

    day_t day = myDate.get_day(); // Date::get_day(&myDate) 
    month_t month = myDate.get_month(); // Date::get_month(&myDate) 
    year_t year = myDate.get_year(); // Date::get_year(&myDate) 

    cout << day << "/" << month << "/" << year << endl; 

    return (0); 
}

#include <iostream> 

using std::cout; 

class Date 
{
    public: 
        typedef int day_t; 
        typedef int month_t; 
        typedef int year_t; 
    private: 
        day_t day; 
        month_t month; 
        year_t year; 
    public: 
        Date(day_t day, month_t month, year_t year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        day_t get_day() {
            return day; 
        }

        month_t get_month() {
            return month; 
        }

        year_t get_year() {
            return year; 
        }
}; 

int main(void) 
{
    Date myDate(1, 1, 1970); 
    Date::day_t day = myDate.get_day(); // Date::get_day(&myDate) 
    Date::month_t month = myDate.get_month(); // Date::get_month(&myDate) 
    Date::year_t year = myDate.get_year(); // Date::get_year(&myDate); 

    cout << day << "/" << month << "/" << year << endl; 

    return (0); 
}

#include <iostream> 

using std::cout; 

class Date 
{
    public: 
        typedef int day_t; 
        typedef int month_t; 
        typedef int year_t; 
    private: 
        day_t day; 
        month_t month; 
        year_t year; 
    public:     
        Date(day_t init_day, month_t init_month, year_t init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        day_t get_day() {
            return day; 
        }

        month_t get_month() {
            return month; 
        }

        year_t get_year() {
            return year; 
        }
}; 

int main(void) 
{
    Date myDate(1, 1, 1970); 
    Date::day_t day = myDate.get_day(); // Date::get_day(&myDate) 
    Date::month_t month = myDate.get_month(); // Date::get_month(&myDate) 
    Date::year_t year = myDate.get_year(); // Date::get_year(&myDate) 

    cout << day << "/" << month << "/" << year << endl; 

    return (0); 
}

#include <iostream> 

using std::cout; 

class Date 
{
    public: 
        typedef int day_t; 
        typedef int month_t; 
        typedef int year_t; 
    private: 
        day_t day; 
        month_t month; 
        year_t year; 
    public:     
        Date(day_t init_day, month_t init_month, year_t init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        day_t get_day() {
            return day; 
        }

        day_t get_month() {
            return month; 
        }

        year_t get_year() {
            return year; 
        }
}; 

int main(void) 
{
    Date myDate(1, 1, 1970); 
    Date::day_t day = myDate.get_day(); // Date::get_day(&myDate) 
    Date::month_t month = myDate.get_month(); // Date::get_month(&myDate) 
    Date::year_t year = myDate.get_year(); // Date::get_year(&myDate) 

    cout << day << "/" << month << "/" << year << endl; 

    return (0); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

int get_roll_number(); 
double get_sal(); 
char* get_addr(); 

typedef int rollnumber_t; 
typedef int salary_t; 
typedef char* addr_t; 

void test_function(void); 

int main(void) 
{
    int x; // x is a roll number; 
    int y; // y is a salary 
    char* z; // s is an address 
    
    // recommended practise 
    int roll_number; 
    double employee_salary; 
    char* address_of_student; 

    return (0); 
}

void test_function(void) 
{
    rollnumber_t get_roll_number(void); 
    salary_t get_salary(void); 
    addr_t get_addr(void); 

    rollnumber_t roll_number; 
    salary_t salary; 
    addr_t address_of_student; 

    roll_number = get_roll_number(); 
    salary = get_salary(); 
    address_of_student = get_address(); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

int get_roll_number(); 
double get_salary(); 
char* get_address(); 

// GOOD PRACTISE 
typedef int roll_number_t; 
typedef double salary_t; 
typedef char* addr_t; 

void test_function(void); 

int main(void) 
{
    int x;      // x is a roll number
    double y;   // y is a salary 
    char* s;    // s is a address 

    // recommended practise 
    int roll_number; 
    double employee_salary; 
    char* address_of_student; 

    return 0; 
}

void test_function(void) 
{
    rollnumber_t get_roll_number(void); 
    salary_t get_salary(void); 
    addr_t get_address(void); 

    rollnumber_t roll_number; 
    salary_t salary_of_employee; 
    addr_t address_of_student; 

    roll_number = get_roll_number(); 
    salary_of_employee = get_salary(); 
    address_of_student = get_address(); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

int get_roll_numeber(); 
double get_salary(); 
char* get_address(); 

// GOOD PRACTISE 
typedef int rollnumber_t; 
typedef double salary_t; 
typedef char* addr_t; 

void test_function(void); 

int main(void) 
{
    int x;      // x is a roll number 
    int y;      // y is a salary 
    char* s;    // s is a address 

    // recommended practise 
    int roll_number; 
    double salary_of_employee; 
    char* address_of_student; 

    return 0; 
}

void test_function(void) 
{
    rollnumber_t get_roll_numeber(void); 
    salary_t get_salary(void); 
    addr_t get_address(void); 

    roll_number_t roll_number; 
    salary_t salary_of_employee; 
    addr_t address_of_student; 

    roll_number = get_roll_number(); 
    salary_of_employee = get_salary(); 
    address_of_student = get_address(); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

int get_roll_number(); 
double get_salary(); 
char* get_address(); 

// GOOD PRACTISE 
typedef int rollnumber_t; 
typedef double salary_t; 
typedef char* address_t; 

void test_function(void); 

int main(void) 
{
    int x;  // x is a roll number 
    double y; // y is a salary of employee 
    char* s;    // s is an address 

    // recommended practise 
    int roll_number; 
    double employee_salary; 
    char* address_of_student; 

    return 0; 
}

void test_function(void) 
{
    rollnumber_t get_roll_numeber(void); 
    salary_t get_salary(void); 
    addr_t get_address(void); 

    rollnumber_t roll_number; 
    salary_t salary; 
    addr_t address; 

    roll_number = get_roll_number(); 
    salary_of_employee = get_salary(); 
    address_of_student = get_address(); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

void test_function(void); 

int main(void) 
{
    int x;      // x is a roll number 
    double y;   // y is a salary 
    char* s;    // s is a address 

    // recommended practise 
    int roll_number; 
    double employee_salary; 
    char* address_of_student; 

    return 0; 
}

void test_function(void) 
{
    rollnumber_t get_roll_number(void); 
    salary_t get_salary(void); 
    addr_t get_address(void); 

    rollnumber_t roll_number; 
    salary_t salary_of_employee; 
    addr_t address_of_student; 

    roll_number = get_roll_number(); 
    salary_of_employee = get_salary(); 
    address_of_student = get_address(); 
}

#include <iostream> 
#include <string> 

void test_1(void); 
void test_2(void); 
void test_3(void); 

int main(void) 
{
    test_1(); 
    test_2(); 
    test_3(); 

    return (0); 
}

void test_1(void) 
{
    std::string str("Hello"); 
    std::string size_type i; 
}

void test_2(void) 
{
    using std::string; 

    string str("Hello"); 
    string::size_type i;  
}

void test_3(void) 
{
    using std::string; 
    using std::string::size_type; 

    string s("Hell0"); 
    size_type i; 
}

#include <iostream> 
#include <string> 

void test_1(void); 
void test_2(void); 
void test_3(void); 

int main(void) 
{
    test_1(); 
    test_2(); 
    test_3(); 

    return 0; 
}

void test_1(void) 
{
    std::string s("Hello"); 
    std::string::size_type i; 
}

void test_2(void) 
{
    using std::string; 

    string s("Hello"); 
    string::size_t i; 
}

void test_3(void) 
{
    using std::string; 
    using std::size_type; 

    string s("Hello"); 
    size_type i = 0;  
}

#include <iostream> 
#include <string> 

void test_1(void); 
void test_2(void); 
void test_3(void); 

int main(void) 
{
    test_1(); 
    test_2(); 
    test_3(); 

    return (0); 
}

void test_1(void) 
{
    std::string s("Hello"); 
    std::string::size_type i; 
}

void test_2(void) 
{
    using std::string; 

    string s("Hello"); 
    string::size_type i; 
}

void test_3(void) 
{
    using std::string; 
    using std::string::size_type; 

    string s("Hello"); 
    size_type i = 0; 
}

#include <iostream> 
#include <string> 

void test_1(void); 
void test_2(void); 
void test_3(void); 

int main(void) 
{

}

void test_1(void) 
{
    std::string s("Hello"); 
    std::string::size_type i = 0; 
}

void test_2(void) 
{
    using std::string; 

    string s("Hello"); 
    string::size_type i; 
}

void test_3(void) 
{
    using std::string; 
    using std::string::size_type; 

    string s("Hello"); 
    size_type i = 0; 
}

#include <iostream> 
#include <string> 

void test_1(void); 
void test_2(void); 
void test_3(void); 

int main(void) 
{
    test_1(); 
    test_2(); 
    test_3(); 

    return 0; 
}

void test_1(void) 
{
    std::string s("Hello"); 
    std::string::size_type i; 
}

void test_2(void) 
{
    using std::string; 

    string s("Hello"); 
    string::size_type i; 
}

void test_3(void) 
{
    using std::string; 
    using string::size_type; 

    string s("Hello"); 
    size_type i; 
}

#include <iostream> 
#include <string> 

void test_1(void); 
void test_2(void); 
void test_3(void); 

int main(void) 
{
    test_1(); 
    test_2(); 
    test_3(); 

    return 0; 
}

void test_1(void) 
{
    std::string s("Hello"); 
    std::string::size_type i; 
}

void test_2(void) 
{
    using std::string; 

    string s("Hello"); 
    string::size_type i; 
}

void test_3(void) 
{
    using std::string;
    using string::size_type; 

    string s("Hello"); 
    size_type i; 
}

#include <iostream> 
#include <cstdlib> 
#include <cstring> 
#include <cassert> 
#include <cstdio> 

namespace sarthak 
{
    class string 
    {
        private: 
            char* p_str; 
            int N; 
        public: 
            typedef int size_type; 

            string() : p_str(0), N(0) {
            }

            string(char* str) {
                int L = strlen(str); 

                p_str = (char*)malloc((L+1) * sizeof(char))
                strncpy(p_str, str, L+1); 
                N = L; 
            }

            string(string& rhs_str) {
                N = rhs_str.N; 
                p_str = (char*)malloc(N+1);   
                strncpy(p_str, rhs_str.p_str, L+1)
            }

            friend std::ostream& operator<<(std::ostream& os, string& os); 

            ~string() {
                if(p_str) 
                {
                    cout << "MEMORY TO STRING IS FREED" << endl; 
                    free(p_str); 
                    p_str = 0; 
                    N = 0;  
                }
            }
    }; 

    std::ostream& operator<<(std::ostream& os, string& s) 
    {
        if(s.p_str) 
            printf("%s", p_str); 
        return os; 
    }
}

int main(void) 
{
    sarthak::string s1; 
    sarthak::string s2("Hello"); 
    sarthak::string s3(s2); 

    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s2: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 

    return 0; 
}

#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cassert> 
#include <iostream> 

using std::cout; 
using std::endl; 

namespace sarthak
{
    class string 
    {
        private: 
            char* str; 
            int N; 
        public: 
            typedef int size_type; 

            string() : p_str(0), N(0) {
            } 

            string(char* s) {
                int L = strlen(s); 

                p_str = (char*)malloc(sizeof(char) * (L+1)); 
                assert(p_str); 
                strcpy(p_str, s, L+1); 
                N = L; 
            }

            // copy constructor 
            string(string& rhs_str) 
            {
                N = rhs_str.N; 
                p_str = (char*)malloc(N+1); 
                assert(p_str); 

                strcpy(p_str, rhs_str, N+1); 
            }

            friend std::ostream& operator<<(std::ostream& os, string& s) 
            {
                if(s.p_str) 
                    printf("%s", s.p_str); 
                return os; 
            }

            ~string() {
                if(p_str) 
                {
                    free(p_str); 
                    p_str = 0; 
                    N = 0; 
                }
            }
    }; 
}

int main(void) 
{
    sarthak::string s1; 
    sarthak::string s2("Hello"); 
    sarthak::string s3(s2); 

    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 

    return 0; 
}

#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cassert> 
#include <iostream> 

using std::cout; 
using std::endl; 

namespace sarthak 
{
    class string 
    {
        private: 
            char* p_str; 
            int N; 

        public: 
            typedef int size_type;

            string() : p_str(0), N(0) {
            }

            string(char* str) {
                int L = strlen(str); 
                p_str = (char*)malloc(L+1); 
                assert(p_str); 
                strncpy(p_str, str, L+1); 
                N = L; 
            }

            // copy constructor 
            string(string& rhs_str) {
                N = rhs_str.N; 
                p_str = (char*)malloc(N+1); 
                strcpy(p_str, rhs_str.p_str, N+1); 
            }

            friend std::ostream& operator<<(std::ostream& os, string& s) {
                if(s.p_str) 
                    printf("%s", s.p_str); 
                return os; 
            }

            ~string() {
                if(p_str) 
                {
                    cout << "MEMORY TO STRING IS FREEND" << endl; 
                    free(p_str); 
                    p_str = 0; 
                }
            }
    }; 
}

int main(void) 
{
    sarthak::string s1; 
    sarthak::string s2("Hello"); 
    sarthak::string s3(s2); 

    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 

    return (0); 
}

#include <cstring> 
#include <cstdio> 
#include <cstdlib> 
#include <cassert> 
#include <iostream> 

using std::cout; 
using std::endl; 

namespace cpa
{
    class string 
    {
        private: 
            char* p_str; 
            int N; 
        public: 
            typedef int size_type; 

            string() : p_str(0), N(0) 
            {} 

            string(char* s) 
            {
                N = s.N; 
                p_str = (char*)malloc(N+1); 
                assert(p_str); 
                strncpy(p_str, s.p_str, N+1); 
            }

            // copy constructor 
            string(string& rhs_string) 
            {
                N = rhs_str.N; 
                p_str = (char*)malloc(N+1); 
                assert(p_str); 
                strncpy(p_str, rhs_string.p_str, N+1); 
            }

            std::ostream& operator<<(std::ostream& os, string& s)
            {
                if(p_str) 
                    printf("%s", s); 
                return os; 
            }

            ~string() {
                if(p_str) 
                {
                    cout << "MEMORY TO STRING IS FREED" << endl; 
                    free(p_str); 
                    p_str = 0; 
                }
            } 
    }; 
}

int main(void) 
{
    cpa::string s1; 
    cpa::string s2("Hello"); 
    cpa::string s3(s2); 

    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 

    return 0; 
}

#include <cstdio> 
#include <cstdlib> 
#include <cassert> 
#include <cstring> 
#include <iostream> 

using std::cout; 
using std::endl; 

namespace cpa 
{
    class string
    {
        private: 
            char* p_str; 
            int N; 
        public: 
            typedef int size_type; 

            string() : p_str(0), N(0) 
            {} 

            string(char* s) 
            {
                int L = strlen(s); 
                p_str = (char*)malloc(L+1); 
                assert(p_str); 
                strcpy(p_str, s, L+1); 
                N = L; 
            }

            // copy constructor 
            string(string& rhs_str) 
            {
                N = rhs_str.N; 
                p_str = (char*)malloc(N+1); 
                assert(p_str); 
                strncpy(p_str, rhs_str, N+1); 
            }

            friend std::ostream& operator<<(std::ostream& os, string& s) 
            {
                if(s) 
                    printf("%s", s); 
                return os; 
            }

            ~string() {
                if(p_str) 
                {
                    cout << "MEMORY TO STRING IS FREED" << endl; 
                    free(p_str); 
                    p_str = 0; 
                }
            }
    }; 
}

int main(void) 
{
    cpa::string s1; 
    cpa::string s2("H1llo"); 
    cpa::string s3(s2); 

    cout << "s1: " << s1 << endl; 
    cout << "s2: " << s2 << endl; 
    cout << "s3: " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 

    return 0; 
}

#include <stdio.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

int main(void) 
{
    int num = 10; 
    printf("num = %d\n", num); // 10 will be printed 
    
    struct Date myDate = {9, 2, 2025}; 
    printf("%d-%d-%d\n", myDate.day, myDate.month, myDate.year); 
    // 9, 2, 2025 

    return (0); 
}

#include <stdio.h> 

struct Date
{
    int day;
    int month; 
    int year; 
}; 

int main(void) 
{
    int num = 10; 
    printf("num = %d\n", num); 

    struct Date myDate = {1, 1, 1970}; 
    printf("%d/%d/%d\n", myDate.day, myDate.month, myDate.year); 

    return (0); 
}

#include <stdio.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

int main(void) 
{
    int num = 10; 
    printf("num = %d\n", num); 

    struct Date myDate = {1, 1, 1970}; 
    printf("%d/%d/%d\n", myDate.day, myDate.month, myDate.year); 

    return (0); 
}

#include <stdio.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

int main(void) 
{
    int num = 10; 
    printf("num = %d\n", num); // 10 will be printed 

    struct Date myDate = {1, 1, 1970}; 
    printf("%d/%d/%d\n", myDate.day, myDate.month, myDate.year); 
    //1, 1, 1970 

    return (0); 
}

#include <stdio.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

int main(void) 
{
    int num = 10; 
    printf("num = %d\n", num); // 10 will be printed 

    struct Date myDate = {1, 1, 1970}; 
    printf("%d/%d/%d\n", myDate.day, myDate.month, myDate.year); // 9, 2, 2025  

    return (0); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public:     
        void init(int _day, int _month, int _year) 
        {
            this->day = _day; 
            this->month = _month; 
            this->year = _year; 
        }

        void show() 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    int num = 100; 
    cout << "num = " << num << endl; 

    Date myDate; // There is no way as of now to initiate an object of Date 
                    // We can add init() function to the class 
    myDate.init(9, 2, 2025); 

    // add show() function 
    myDate.show(); // 9, 2, 2025 

    return 0; 
}

//  At C++ syntax level, allocate of memory to Date object is done by 
// Date myDate; 

// Setting value for the first time is done by 
// myDate.init(1, 1, 1970); 

// There are two separate steps and therefore do not come under category of initialization 
// If we could do something like Date myDate(1, 1, 1970) then 
// it will come under initialization 

// Date myDate(1, 1, 1970) 
// After reading this, C++ compiler should 
// 1) allocate memory of 12 bytes for new object, name that object as myDate  
// 2) And then INTERNALLY CALL init() function on myDate with 1, 1, 1970 as actual parameters 

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year;
    public:     
        void init(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    int num = 100; 
    cout << "num = " << num << endl; // 10 will be printed 

    Date myDate; // There is no way of initialization as of now 
                 // to initialize an object of Date we can add init() function to class 
    myDate.init(1, 1, 1970); 

    // add show() function 
    myDate.show(); // Date::show(&myDate); 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public: 
        void init(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // void show(Date* this)  
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    int num = 10; 
    cout << "num = " << num << endl; 

    Date myDate; // There is no way of initialization as of now to initializw an object of Date 
                 // we can add init() function to class 
    myDate.init(1, 1, 1970); 

    // add show() function 
    myDate.show(); // Date::show(&myDate) 
    // 1, 1, 1970 
}

// At C++ syntax level, allocation of memory to Date object is done by 
// Date myDate; 

// Setting values for the first time is done by 
// myDate.init(9, 2, 2025); 

// These are two steps, hence do not come under the category of initialization 
// If we could do something like Date myDate(1, 1, 1970) 
// then it will come under initialization 

// Date myDate(1, 1, 1970) 
// After reading this line, C++ should, first allocate memory of 12 bytes 
// for new object of class Date, name that memory block as myDate. 
// And then INTERNALLY CALL init() function on myDate with 1, 1, 1970 as actual parameters 

#include <iostream> 
#include <iostream> 

using std::cout; 
using std::endl; 
using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public:     
        void init(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // Date::show(Date* this) 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }    
}; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public: 
        void init(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // Date::show(Date* this) 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    int num = 10; 
    cout << "num = " << num << endl; // 10 will be printed 

    Date myDate; // There is no way of initialization as of now 
                 // to initialize an object of Date we can add init() function 
    myDate.init(9, 2, 2025); // Date::init(&myDate, 9, 2, 2025)
     
    // add show() function
    myDate.show(); // Date::show(&myDate) 

    return 0; 
}

int main(void) 
{
    int num = 10; 
    cout << "num = " << num << endl; // 10 will be printed 

    Date myDate; // there is no way of initialization as of now 
                 // to initialize an object to Date we can add init() function 
    myDate.init(9, 2, 2025); // Date::init(&myDate, 9, 2, 2025) 

    myDate.show(); // Date::show(&myDate) 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public: 
        // CONSTRUCTOR FUNCTION 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

int main(void) 
{
    Date myDate(9, 2, 2025); 
    // 12 bytes of memory block will be allocated to Date object 
    // Make call to Date::Date(addr_of_new_object, 9, 2, 2025); 
    myDate.show(); 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public:     
        // CONSTRUCTOR FUNCTION 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // show(Date* this) 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    Date myDate(1, 1, 1970); 
    // 12 bytes of memory block will be allcated to Date object 
    // Make call to Date::Date(&myDate, 1, 1, 1970) 
    myDate.show(); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year;
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // Date::show(Date* this) 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    Date myDate(9, 2, 2025); 
    // 12 bytes of memory block will be allocated to Date object 
    // Make call to Date::Date(&myDate, 1, 1, 1970) 
    myDate.show(); // Date::show(&myDate); 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // Date::show(&myDate) 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    Date::myDate(9, 2, 2025); 
    // 12 bytes of memory block will be allocated to Date object 
    // Make call to Date::Date(&myDate, 9, 2, 2025) 
    myDate.show(); // Date::show(&myDate) 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // void show(Date* this) 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    Date myDate(9, 2, 2025); 
    // 12 bytes of memory will be allocated to Date object 
    // Make call to Date::Date(&myDate, 9, 2, 2025) 
    myDate.show(); 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 

    public: 
        // CONSTRUCTOR DEFINITION 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() // Date::show(Date* this) 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    Date myDate(9, 2, 2025); 
    // 12 bytes of memory will be allocated to Date object 
    // Make call to Date::Date(&myDate, 9, 2, 2025); 
    myDate.show(); 

    return 0; 
}
=============================== 08 MARCH =========================================================================================
#include <iostrea> #includ e<iostream> #include <iostream> 
<iostream> iostrea> #includ e<iostream> #include <iostream> #include <iostream> #include <iostream. #include <iostream> #include <iostream> #include <iostream> #include <iostream> 
#include <iostream> #include <iostream> #Include <iostream> 

#include <iostream> 
#include <string> 
#include <vector> 

using std::cout; 
using std::endl; 
using std::string; 
using std::string; 

class Date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    // vector of ints 
    vector<int> ivec1; 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> ivec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100); 

    // transverse thorough all vectors 
    // ivec1: using index 
    cout << "ivec1: using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec1.size(); ++i) 
        cout << "ivec1[" << i << "] = " < ivec1[i] << endl; 

    cout << "ivec1: using iterator" << endl; 
    for(vector<int>::iterator iter = ivec1.begin(); iter != ivec1.end(); ++ivec1)
        cout << "*iter = " << *iter << endl; 

    for(vector<int>::iterator iter = ivec1.begin(); iter != ivec1.end(); ivec1++) 
        cout << "*iter = " << *iter << endl; 

    for(vector<int>::iterator iter = ivec1.begin();  iter != ivec2.end(); iter = iter + 1) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec2 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec2.size(); ++i) 
        cout << "ivec2[" << i << "] = " << ivec2[i] << endl; 

    cout << "ivec2 : using iterator " << endl; 
    for(vector<int>::iterator iter = ivec2.begin(); iter != ivec2.end(); ++iter)
        cout << "*iter = " << *iter << endl; 

    cout << "ivec3 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec3.size(); ++i) 
        cout << "ivec3[" i << "] = " << ivec3 << endl; 

    cout << "ivec3: using iterator" << endl; 
    for(vector<int>::iterator iter = ivec3.begin(); iter != ivec3.end(); ++iter ) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec4 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec4.size(); ++i) 
        cout << "ivec4[" << i << "] = " << ivec4[i] << endl; 

    cout << "ivec4 : using iterator" << endl; 
    for(vector<int>::iterator iter = ivec4.begin(); iter != ivec4.end(); ++iter)
        cout << "*iter = " << iter << endl; 

    cout << "ivec5 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec5.size(); ++i) 
        cout << "ivec5[" << i << "] = " << ivec5[i] << endl; 

    cout << "ivec5: using iterator " << endl; 
    for(vector<int>::iterator iter = ivec5.begin(); iter != ivec5.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    vector<float> fvec1; 
    vector<float> fvec2{1.1f, 2.2f, 3.3f, 4.4f}; 
    vector<float> fvec3(fvec2); 
    vector<float> fvec4(5); 
    vector<float> fvec5(5, 100); 

    cout << "---------------" << endl; 
    cout << "fvec1 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec1.size(); ++i) 
        cout << "fvec1[" << i << fvec1[i] << endl; 

    for(vector<float>::iterator iter = fvec1.begin(); iter != fvec1.end(); ++iter) 
        cout << "*iter = " << iter << endl; 

    cout << "fvec2 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec2.size(); ++i) 
        cout << "fvec2[" << i << "] = " << fvec2[i] << endl; 

    cout << "fvec2 : using iterator" << endl; 
    for(vector<int>::iterator iter = fvec2.begin(); iter != fvec2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec3 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < fvec3.size(); ++i) 
        cout << "fvec3[" << i << "] = " << endl; 

    for(vector<int>::iterator iter = fvec3.begin(); iter != fvec3.end(); ++iter ) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec4 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < ivec4.size(); ++i) 
        cout << "fvec4[" << i << "] = " << fvec4[i] << endl; 
    
    cout << "fvec4 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec4.begin(); iter != fvec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec5 : using index " << endl; 
    for(vector<float>::size_type i = 0; i < fvec5.size(); ++i) 
        cout << "fvec5[" << i << "] = " << fvec5[i] << endl; 

    cout << "fvec5 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec5.begin(); iter != fvec5.end(); ++iter) 
        cout << "*iter = " << *iter << endl;  
    //-------------- 
    
    vector<string> str_vec1;  // empty
    vector<string> str_vec2{
                    string("Hello"), 
                    string("World"), 
                    string("Iterator"), 
                    string("Amazing!")
                };
    vector<string> str_vec3(str_vec2); 
    vector<string> str_vec4(5); 
    vector<string> str_vec5(5, "ONE"); 

    cout << "str_vec1 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec1.size(); ++i) 
        cout << "str_vec1[" << i << "] = " << str_vec1[i] << endl; 

    cout << "str_vec1 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec1.begin(); iter != str_vec1.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec2 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec2.size(); ++i) 
        cout << "str_vec2[" << i << "] = " << str_vec2[i] << endl; 

    cout << "str_Vec2: using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec2.begin(); iter != str_vec2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec3 : using index " << endl; 
    for(vector<string>::size_type i = 0; i < str_vec3.size(); ++i) 
        cout << "str_vec3[" << i << str_vec3[i] << endl; 

    cout << "str_vec3: using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec3.begin(); iter != str_vec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec4 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec4.size(); ++i)  
        cout << "str_vec4[" << i << "] = " << str_vec4[i] << endl; 

    cout << "str_vec4 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec4.begin(); iter != str_vec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec5 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec5.size(); ++i) 
        cout << "str_vec5[" << i << "] = " << str_vec5[i] << endl; 

    cout << "str_vec5 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec5.begin(); iter != str_vec5.end(); ++iter )
        cout << "*iter = " << *iter << endl; 
    // --------------- 

    vector<Date> date_vec1; 
    vector<Date> date_vec2{
        Date(8, 3, 2025), 
        Date(9, 3, 2025), 
        Date(10, 3, 2025), 
        Date(11, 3, 2025) 
    }; 
    vector<Date> date_vec3(date_vec2); 
    vector<Date> date_vec4(5); 
    vector<Date> date_vec(5, Date(9, 3, 2025)); 

    cout << "date_vec1: using index " << endl; 
    for(vector<string>::size_type i = 0; i < date_vec1.size(); ++i) 
        date_vec1[i].show(); 

    cout << "date_vec1 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec1.begin(); iter != date_vec1.end(); ++iter) 
        iter->show(); 

    cout << "date_vec2 : using_index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec1.size(); ++i) 
        date_vec1[i].show(); 

    cout << "date_vec1: using iteratoe" << endl; 
    for(vector<Date>::iterator iter = date_vec1.begin(); iter 1= date_vec1.end(); ++iter) 
        iter->show(); 

    cout << "date_vec2 : using index" << endl; 
    for(vector<Date>::size_type  = 0; i < date_vec2.size(); ++i) 
        date_vec2[i].show(); 

    cout << "date_vec2 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec2.begin(); iter != date_vec2.end(); ++iter ) 
        iter->show(); 

    cout << "date_vec3: using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec3.size(); ++i) 
        date_vec3[i].show(); 

    cout << "date_vec3 : using index" << endl; 
    for(vector<Date>::iterator iter = date_vec3.begin(); iter != date_vec3.end(); ++iter) 
        iter->show(); 

    cout << "date_vec4: using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec4.size(); ++i) 
        date_vec4[i].show(); 

    cout << "date_vec4 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec4.begin(); iter != date_vec4.end(); ++iter) 
        iter->show(); 

    cout << "date_vec5 : using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec5.size(); ++i) 
        date_vec5[i].show(); 

    cout << "date_vec5 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec5.begin(); iter != date_vec5.end(); ++iter ) 
        iter->show(); 
}

struct Date myDate = {1, 1, 1970}; 
struct Date* pDate = &myDate; 
(*pDate).month == pDate->month 
(*pDate).day   == pDate->day; 
(*pDate).year  == pdate->year 

#include <iostream> 
#include <string> 
#include <vector> 

using std::cout; // object of class ostream | class ostream and object cout are defined in std namespace 
using std::endl;  // endl is defined in namespace std 
using std::string; // string is class defined in std namesoace 
using std::vector; // vector is a 'class template' defined in std namespace 

class date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    // vector of integers 
    vector<int> ivec1; // empty 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> ivec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100); 

    cout << "ivec1 : using idex" << endl; 
    for(vector<int>::size_type i = 0; i < ivec1.size(); ++i) 
        cout << "ivec1[" << i << "] = " << ivec1[i] << endl; 

    cout << "ivec1 : using iterator" << endl; 
    for(vector<int>::iterator iter = ivec1.begin(); iter != ivec1.end(); ++iter ) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec2: using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec1.size(): ++i) 
        cout << "ivec2[" << i << "] = " << ivec2[i] << endl; 

    cout << "ivec2 : using iterator " << endl; 
    for(vector<int>::size_type iter = ivec3.begin(); iter != ivec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec3 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec2.size(); ++i) 
        cout << "ivec3[" << i << "] = " << ivec3[i] << endl; 

    cout << "ivec3 : using iterator " << endl; 
    for(vector<int>::iterator iter = ivec3.begin(); iter != ivec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec4: using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec4.size(); ++i); 
        cout << "ivec4[" << i << "] = " << ivec4[i] << endl; 

    cout << "ivec4 : using iterator" << endl; 
    for(vector<int>::iterator iter = ivec4.begin(); iter != ivec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec5 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec5.size(); ++i) 
        cout << "ivec5[" << i << "] = " << ivec5[i] << endl; 

    cout << "ivec5 : using iterator" << endl; 
    for(vector<int>::iterator iter = ivec5.begin(); iter != ivec5.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    // vector of floats 
    vector<float> fvec1; 
    vector<float> fvec2{1.1f, 2.2f, 3.3f, 4.4f}; 
    vector<float> fvec3(fvec3); 
    vector<float> fvec4(5); 
    vector<float> fvec5(5, 1.1f); 

    cout << "fvec1 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec1.size(); ++i) 
        cout << "fvec1[" << i << "] = " << fvec1[i] << endl; 

    cout << "fvec1 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec1.begin(); iter = fvec1.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec2 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec2.size(); ++i) 
        cout << "fvec2[" << i << "] = " << fvec2[i] << endl; 

    cout << "fvec2 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec2.begin(); iter != fvec2.end(); ++iter)  
        cout << "*iter = " << *iter << endl; 

    cout << "fvec3 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec3.size(); ++i) 
        cout << "fvec3[" << i << "] = " << fvec3[i] << endl; 

    cout << "fvec3 : using iterator " << endl; 
    for(vector<float>::iterator iter = fvec3.begin(); iter != fvec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec4 : using index" << endl; 
    for(vector<float>::size_type i = 0 ; i < fvec4.size(); ++i) 
        cout << "fvec4[" <<  i << "] = " << fvec4[i] << endl; 

    cout << "fvec4 : using iterator " << endl; 
    for(vector<float>::iterator iter = fvec4.begin(); iter != fvec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 
    
    cout < "fvec5 : using indeX" << endl; 
    for(vector<float>::size_type i = 0;  i < fvec5.size(); ++i) 
        cout << "fvec[" << i << "] = " << fvec[i] << endl; 

    cout << "fvec5 : using iterator" << endl; 
    for(vector<int>::iterator iter = fvec5.begin(); iter != fvec5.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    // vector of string 
    vector<string> str_vec1; 
    vector<string> str_vec2{
                string("Hello"), 
                string("World"), 
                string("Iterator"), 
                string("Amazing!")
            }; 
    vector<string> str_vec3(str_vec2); 
    vector<string> str_vec4(5); 
    vector<string> str_vec5(5, string("ONE")); 

    cout << "str_vec1: using index" << endl; 
    for(vector<string>::size_type i = 0; i < fvec1.size(); ++i) 
        cout << "str_vec[" << i << "] = " << str_vec1[i] << endl; 

    cout << "str_vec1 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec1.begin(); iter != str_vec1.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec2 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec2.size(); ++i) 
        cout << "str_vec2[" << i << "] = " << str_vec2[i] << endl; 
    
    cout << "str_vec2: using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec2.begin(); iter != str_vec2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec3 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec3.size(); ++i) 
        cout << "str_vec3[" << i << "] = " << str_vec3[i] << endl; 

    cout << "str_vec3 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec3.begin(); iter != str_vec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec4 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec4.size(); ++iter) 
        cout << "str_vec4[" << i << "] = " << str_vec4[i] << endl; 

    cout << "str_vec4 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vc4.begin(); iter != str_vec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec5 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec5.size(); ++i) 
        cout << "str_Vec5[" << i << "] = " << str_vec5[i] << endl; 

    cout << "str_vec5: using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec5.begin(); iter != str_vec5.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    // vector of string date 
    vector<Date> date_vec1; 
    vector<Date> date_vec2{
                    Date(9, 2, 2025), 
                    Date(10, 2, 2025), 
                    Date(11, 2, 2025), 
                    Date(12, 2, 2025) 
                }; 
    vector<Date> date_vec3(date_vec2); 
    vector<Date> date_vec4(5); 
    vector<Date> date_vec5(5, Date(1, 1, 1970)); 

    cout << "date_vec1 : using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec1.size(); ++i) 
        date_vec1[i].show(); // Date::show(date_vec1);  

    cout << "date_vec : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec1.begin(); iter != date_vec1.end(); ++iter) 
        iter->show(); 

    cout << "date_vec2 : using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec2.end(); ++i) 
        date_vec2[i].show(); // Date::show(&date_vec2[i]); 

    cout << "date_vec2 : using iterator " << endl; 
    for(vector<Date>::iterator iter; iter != date_vec2.end(); iter++) 
        iter->show(); 

    cout << "date_vec3: using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec3.size(); ++i) 
        date_vec3[i].show(); 

    cout << "date_vec3 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec4.begin(); iter != date_vec4.end(); ++iter) 
        iter->show(); 

    cout << "date_vec4 : using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec4.size(); ++i) 
        date_vec4[i].show(); 

    cout << "date_vec4 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec4.begin(); iter != date_vec4.end(); ++iter) 
        iter->show(); 

    cout << "date_vec5 : using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec5.size(); ++i) 
        date_vec5[i].show(); 

    cout << "date_vec5: using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec5.begin(); iter != date_vec5.end(); ++iter)   
        iter->show(); 
}

#include <iostream> 
#include <string> 
#include <vector> 

using std::cout; 
using std::endl; 
using std::string; 
using std::vector; 

class Date 
{
    private: 
        int day, month, year; 
    public: 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

void vector_demo(void); 

int main(void) 
{
    vector_demo(); 
    return 0; 
}

void vector_demo(void) 
{
    // vector of int 
    vector<int> ivec1; 
    vector<int> ivec2{10, 20, 30, 40, 50}; 
    vector<int> ivec3(ivec2); 
    vector<int> ivec4(5); 
    vector<int> ivec5(5, 100); 

    cout << "ivec1 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec1.size(); ++i) 
        cout << "ivec1[" << i << "] = " << ivec1[i] << endl; 

    cout << "ivec1: using iterator" << endl; 
    for(vector<int>::iterator iter = ivec1.begin(); iter != ivec1.end(); ++iter ) 
        cout << "*iter = " << *iter << endl; 
    
    cout << "ivec2 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec2.size(); ++i) 
        cout << "ivec2[" << i << "] = " << ivec2[i] << endl; 

    cout << "ivec2 : using iterator" << endl; 
    for(vector<int>::iterator iter = ivec2.begin(); iter != ivec2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec3 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec3.size(); ++i) 
        cout << "ivec[" << i << "] = " << ivec3[i] << endl; 

    cout << "ivec3 : using iterator" << endl; 
    for(vector<int>::iterator iter = ivec3.begin(); iter != ivec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec4 : using inex" << endl; 
    for(vector<int>::size_type i = 0; i < ivec4.size(); ++i) 
        cout << "ivec4[" << i << "] = " << ivec4[i] << endl; 

    cout << "ivec4 : using iterator" << endl; 
    for(vector<int>::iterator iter = ivec4.begin(); iter != ivec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "ivec5 : using index" << endl; 
    for(vector<int>::size_type i = 0; i < ivec5.size(); ++i) 
        cout << "ivec5[" << i << "] = " << ivec5[i] << endl; 
    
    cout << "ivec5: using iterator" << endl; 
    for(vector<int>::iterator iter = ivec5.begin(); iter != ivec6.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    // vector of float 
    vector<float> fvec1; 
    vector<float> fvec2{1.1f, 2.2f, 3.3f, 4.4f}; 
    vector<float> fvec3(fvec3); 
    vector<float> fvec4(5); 
    vector<float> fvec5(5, 1.1f); 

    cout << "fvec1 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec1.size(); ++i) 
        cout << "fvec1[" << i << "] = " << fvec[i] << endl; 

    cout << "fvec1 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec1.begin(); iter != fvec1.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec2 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec2.size(); ++i) 
        cout << "fvec2[" << i << "] = " << fvec2[i] << endl; 

    cout << "fvec2 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec2.begin(); iter != fvec2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec3 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec3.size(); ++i) 
        cout << "fvec3[" << i << "] = " << fvec3[i] << endl; 
    
    cout << "fvec3 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec3.begin(); iter != fvec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec4: using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec4.size(); ++i) 
        cout << "fvec4[" << i << "] = " << fvec4[i] << endl; 
    
    cout << "fvec4 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec3.begin(); iter != fvec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "fvec5 : using index" << endl; 
    for(vector<float>::size_type i = 0; i < fvec1.size(); ++i) 
        cout << "fvec5[" << i << "] = " << fvec5[i] << endl; 

    cout << "fvec5 : using iterator" << endl; 
    for(vector<float>::iterator iter = fvec5.begin(); iter != fvec5.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    // vector of string 
    vector<string> str_vec1; 
    vector<string> str_vec2{
                    string("Hello"); 
                    string("World"); 
                    string("Amazing"); 
                    string("CPP"); 
                }; 
    vector<string> str_vec3(str_vec2); 
    vector<string> str_vec4(5); 
    vector<string> str_vec5(5, string("CPA-CPP")); 

    cout << "str_vec1: using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec1.size(); ++i) 
        cout << "str_vec1[" << i << "] = " << str_vec1[i] << endl; 

    cout << "str_vec1 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec1.begin(); iter != str_vec1.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec2 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec2.size(); ++i) 
        cout << "str_vec2[" << i << "] = " << str_vec2[i] << endl; 

    cout << "str_vec2 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec2.begin(); iter != str_vec2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec3: using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec3.size(); ++i) 
        cout << "str_vec3[" << i << "] = " << str_vec3[i] << endl; 

    cout << "str_vec3 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec3.begin(); iter != str_vec3.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec4 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec4.size(); ++i) 
        cout << "str_vec4[" << i << "] = " << str_vec4[i] << endl; 
    
    cout << "str_vec4 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec4.begin(); iter != str_vec4.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    cout << "str_vec5 : using index" << endl; 
    for(vector<string>::size_type i = 0; i < str_vec5.size(); ++i) 
        cout << "str_vec5[" << i << "] = " << str_vec5[i] << endl; 

    cout << "str_vec5 : using iterator" << endl; 
    for(vector<string>::iterator iter = str_vec5.begin(); iter != str_vec5.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 

    // vector of Date 
    vector<Date> date_vec1; 
    vector<Date> date_vec2{
                    Date(8, 3, 2025), 
                    Date(9, 3, 2025), 
                    Date(10, 3, 2025), 
                    Date(11, 3, 2025) 
                }; 
    vector<Date> date_vec3(date_vec2); 
    vector<Date> date_vec4(5); 
    vector<Date> date_vec5(5, Date(1, 1, 1970)); 
     
    cout << "date_vec1: using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec1.size(); ++i) 
        date_vec1[i].show(); 

    cout << "date_vec1 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec1.begin(); iter != date_vec1.end(); ++iter) 
        iter->show(); 

    cout << "date_vec2 : using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec2.size(); ++i) 
        date_vec2[i].size(); 

    cout << "date_vec2 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec2.begin(); iter != date_vec2.end(); ++iter) 
        iter->show(); 

    cout << "date_vec3: using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec3.size(); ++i) 
        date_vec3[i].show(); 

    cout << "date_vec3 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec3.begin(); iter != date_vec3.end(); ++iter) 
        iter->show(); 

    cout << "date_vec4 : using index" << endl; 
    for(vector<Date>::size_type i = 0; i < date_vec4.size(); ++i) 
        date_vec4[i].show(); 

    cout << "date_vec4 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec4.begin(); iter != date_vec4.end(); ++iter) 
        iter->show(): 

    cout << "date_vec5 : using index" << endl; 
    for(vector<Date>::size_type i =0 ; i < date_vec5.size(); ++i) 
        date_vec5[i].show(); 

    cout << "date_vec5 : using iterator" << endl; 
    for(vector<Date>::iterator iter = date_vec1.begin(); iter != date_vec1.end(); ++iter)   
        iter->show(); 
}

#include <stdio.h> 
#include <stdlib.h> 

void int_demo(void); 

int main(void) 
{
    int_demo(); 
    return (0); 
}

void int_demo(void) 
{
    int* p =  NULL; 

    p = (int*)malloc(sizeof(int)); 
    if(p == NULL) 
    {
        puts("Error in allocating memory"); 
        exit(-1); 
    }

    *p = 100; 
    printf("%d\n" *p); 

    free(p); 
    p = NULL; 
}

#include <stdio.h> 
#include <stdlib.h> 

void int_demo(void); 

int main(void) 
{
    int_demo(); 
    return (0); 
}

void int_demo(void) 
{
    int* p = NULL; 

    p = (int*)malloc(sizeof(int)); 
    if(p == NULL) 
    {
        printf("Error in allocating memory"); 
        return (0); 
    }

    *p = 100; 
    printf("%d\n", *p); 

    free(p); 
    p = NULL; 
}

#include <iostream> 
#include <vector> 
#include <cmath> 

double rms(std::vector<double>& d_vec) 
{
    double rms_sum = 0.0; 

    if(d_vec.size() == 0) 
        return (0.0); 

    for(std::vector<double>iterator iter = d_vec.begin(); iter != d_vec.end(); ++iter) 
    {
        double d = *iter; 
        rms_sum += d * d; 
    }   
    
    return sqrt(rms_sum/d_vec.size()); 
}

double rms(std::vector<double>& d_vec) 
{
    double rms_sum = 0.0; 

    for(std::vector<double>::iter = d_vec.begin(); iter != d_vec.end(); ++iter) 
        rms_sum = (*iter) * (*iter); 

    return sqrt(rms_sum/d_vec.size()); 
}

================================================= 09 MARCH ================================================================================================================
// Stage 1: PROCEDURAL PROGRAMMING : USING BUILT IN FUNCTIONS 
#include<stdio.h> 

int main(void) 
{
    double G = 6.67 * 10e-11;   // universal constant of gravitation 
    double m1;         // for storing mass of object 1 in kg
    double m2;          // for storing mass of object 2 in kgs
    double r;          // for storing distance between objects in meter 
    double F;           // for storing force in Newtons 

    printf("Enter mass of object 1 in kgs: "); 
    scanf("%lf", &m1); 

    printf("Enter mass of object 2 in kgs: " ); 
    scanf("%lf", &m2); 

    pintf("Enter distance between the objects in meters: "); 
    scanf("%lf", &r); 

    if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
    {
        printf("Invalid values for mass or distance\n"); 
        return (-1); 
    }

    F = (G * m1 * m2) / (r * r); 

    printf("Force of gravitation : %lf Newton\n", F); 

    return (0); 
}

#include <stdio.h> 

int main(void) 
{
    double G = 6.67 * 10e-11; // universal constant of gravitational 
    double m1;  // for storing mass of object 1 in kgs 
    double m2;  // for storing mass of object 2 in kgs 
    double r;   // for storing distance between objects in meter 
    double F;   // for storing force in Newton 

    printf("Enter mass of object 1 in kgs : "); 
    scanf("%lf", &m1); 

    printf("Enter mass of object 2 in kgs : "); 
    scanf("%lf", &m2); 

    printf("Enter distance between the objects in meter : "); 
    scanf("%lf", &r); 

    if(m1 <= 0.0f || m2 <= 0.0f || r <= 0.0f) 
    {
        printf("Invalid values for mass and/or distance"); 
        return (-1); 
    }

    F = (G * m1 * m2) / (r * r); 

    printf("Force of gravitation = %lf Newton", F); 

    return (0); 
}

#include <stdio.h> 

int main(void) 
{
    double G = 6.67 * 10e-11; // gravitational constant 
    double m1; // for storing mass og object 1 in kgs
    double m2: // for storing mass of object 2 in kgs
    double r;  // for storing distance between objects in meters 
    double F;  // for storing force of gravitation in Newton 

    printf("Enter mass of object 1 in kgs"); 
    scanf("%lf", &m1); 

    printf("Enter mass of object 2 in kgs"); 
    scanf("%lf", &m2); 

    printf("Enter distance in objects in meter"); 
    scanf("%lf", &r); 

    if(m1 = 0.0 || m2 <= 0.0 || r <= 0.0) 
    {
        printf("Invalid values for mass and/or distance"); 
        return (-1); 
    }

    F = (G * m1 * m2) / (r * r); 

    printf("Gravitational force = %lf Newton\n", F); 

    return (0); 
}

// STAGE 2 : OBJECT BASED PROGRAMMING IN C++ : USING BUIT IN OBJECTS 
#include <iostream> 

int main(void) 
{
    using std::cout; // ostream | std::ostream 
    using std::cin; // istream | std::istream 

    double G = 6.67 * 10e-11; // universal constant of gravitation 
    double m1; // for storing mass of object 1 in kgs 
    double m2; // for storing mass of object 2 in kgs 
    double r;  // for storing distance between objects 
    double F;  // for storing force of gravitation in Newton 

    cout << "Enter mass of object 1 in kgs : " << endl; 
    cin >> m1; 

    cout << "Enter mass of object 2 in kgs : " << endl; 
    cin >> m2; 

    cout << "Enter distance between objects in meters : " << endl; 
    cin >> r; 

    if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
    {
        cout << "Invalid values for mass and/or distace" << endl; 
        return (-1); 
    }

    F = (G * m1 * m2) * (r * r) 

    cout << "Force of gravitation = " << F << " Newtons" << endl; 

    return (0); 
}

// STAGE 2 : OBJECT BASED PROGRAMMING IN C++ : USING BUILT IN FUNCTIONS 
#include <iostrem> 

int main(void) 
{
    using std::endl; 
    using std::cout; 
    using std::cin; 

    double G = 6.67 * 10e-11; // universal constant of gravitation 
    double m1; // for storing mass of object 1 in kgs 
    double m2; // for storing mass of object 2 in kgs 
    double r; // for storing distance between objects in meter 
    double F; // for storing force in  Newton 

    cout << "Enter mass of object 1 in kgs: "; 
    cin >> m1; 

    cout << "Enter mass of object 2 in kgs : "; 
    cin >> m2; 

    cout << "Enter distance in meter : "; 
    cin >> r; 

    if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
    {
        cout << "Invalid values for massand/or distance" << endl; 
        return (-1); 
    }

    F = (G * m1 * m2) / (r * r); 

    cout << "Gravitational force = " << F << " Newton" << endl; 

    return (0); 
}

#include <iostream> 

int main(void) 
{
    using std::cout; 
    using std::cin; 
    using std::endl; 

    double G = 6.67 * 10e-11; // for universal gravitational constant 
    double m1; // for storing mass of object 1 in kgs 
    double m2; // for storing mass of object 2 in kgs 
    double r; // for storing distance in objects in meter 
    double F; // for storing force in Newton 

    cout << "Enter mass of object 1 in kgs : "; 
    cin >> m1; 

    cout << "Enter mass of object  2 in kgs : "; 
    cin >> m2; 

    cout << "Enter distance between objects in meters : "; 
    cin >> r; 

    if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
    {
        cout << "invalid values for mass and/or distance" << endl; 
        return (-1); 
    }

    F = (G * m1 * m2) / (r * r); 

    cout << "Gravitational force = " << F << " Newton" << endl; 

    return (0); 
}

#include  <iostream> 
int main(void) 
{
    cout << "Hello world!" << endl; 
    return (0); 
}

#include <iostream> 
int main(void) 
{
    cout << "Hello CPP !" << endl; 
    return (0); 
}

#include <iostream> 
int main(void) 
{
    cout << "hello cpp, I am in" << endl; 
    return (0); 
}

#include <iostream> 
int main(void) 
{
    cout << "Hello world!" << endl; 
    return (0); 
}

#include <iostream> 
int main(void) 
{
    cout << "Hello World!" << endl; 
    return (0); 
}

#include <iostream> 
int main(void) 
{
    cout << "Hello World!" << endl; 
    return 0; 
}

#include <iostream> 
int main(void) 
{
    cout << "Hello World!" << endl; 
    return 0; 
} 

#include <iostream> 
int main(void) 
{
    cout << "Hello World!" << endl; 
    return 0; 
}

// StaGE 3 : USING USER DEFINED DATA type 
#include <stdio.h> 
#include <stdlib.h> 
#include <math.h> 

// definition of structure MassAndDistance capturing mass and distance 
// data of objects 
struct MassAndDistace 
{
    double m1; 
    double m2; 
    double r; 
}; 

// function declaration
double ComputeGravitational(struct MassAndDistance* pData); 

int main(void) 
{
    // variables
    struct MassAndDistance Earthsun; 
    struct MassAndDistance JupitorSun; 
    double ForceBetweenEarthAndSun; 
    double ForceBetweenJupitorAndSun; 

    // code 
    Earthsun.m1 = 1.9198e30; 
    EarthSun.m2 = 9.9722e24; 
    EarthSun.r = 149597871000; 

    ForceBetweenEarthAndSun = ComputeGravitational(&EarthSun); 
    printf("Gravitational force between earth and sun = %lf Newton", ForceBetweenEarthAndSun); 

    Jupitorsun.m1 = 1.9891e30; 
    JupitorSun.m2 = 1.89813e27; 
    JupitorSun.r = 149597871000; 

    ForceBetweenJupitorAndSun = ComputeGravitational(&JupitorSun); 
    printf("Gravitational force between Jupitor and Sun = %lf Newton", ForceBetweenJupitorAndSun); 

    return (0); 
}

void ComputeGravitational(struct MassAndDistance* pData) 
{
    // variable declarations 
    double G = 6.67 * 10e-11; .. universal constant of gravitation 
    double F; // for storing amount of force in Newton 

    // code 
    if(pData->m1 <= 0.0 || pData->m2 <= 0.0 || pData->r <= 0.0) 
        return (NAN); 

    F = (G  * pData->m1 * pData->m2) / (pData->r * pData->r); 
    return (F); 
}

#include <stdio.h> 
#include <math.h> 

// defining structure MassAndDistance for storing Mass and Distance data of objects. 
struct MassAndDistance 
{
    double m1; 
    double m2; 
    double r; 
}; 

// function declaration 
double ComputeGravitational(struct Date* pData); 

int main(void) 
{
    // variable declarations 
    struct MassAndDistance EarthSun; 
    struct MassAndDistance JupitorSun; 
    double ForceBetweenEarthAndSun; 
    double ForceBetweenJupitorAndSun; 

    // code 
    EarthSun.m1 = 1.9198e30; 
    EarthSun.m2 = 5.9722e24; 
    EarthSun.r = 149597871000; 

    ForceBetweenEarthAndSun = ComputeGravitational(&EarthSun); 
    printf("Gravitational force between the Earth and the sun = %lf Newtin\n", ForceBetweenEarthAndSun); 

    JupitorSun.m1 = 1.9198e30; 
    JupitorSun.m2 = 1.89813e27; 
    JupitorSun.r = 760070000000; 

    ForceBetweenJupitorAndSun = ComputeGravitational(&JupitorSun); 
    printf("Gravitational force between the Jupitor and the Sun is = %lf Newton\n", ForceBetweenJupitorAndSun); 
}

double ComputeGravitational(struct Data* pData) 
{
    // variable declaration 
    double G = 6.67 * 10e-11; // universal gravitational constant 
    double F; // for storing force in Newton 

    if(pData->m1 <= 0.0 || pData->m2 <= 0.0 || pData->m3 <= 0.0) 
        return (NAN); 

    F = (G * pData->m1 * pData->m2) / (pData->r * pData* r); 
    return (F); 
}

#include <iostream> 
#include <exception> 
#include <cmath> 

// class definitiom 
class MassAndDistance 
{
    private: 
        double m1, m2, r; 
    public: 
        MassAndDistance(double _m1, double _m2, double _r) 
        {
            if(_m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
                throw std::domain_error("Bad input values"); 
            
            m1 = _m1; 
            m2 = _m2; 
            r = _r; 
        }

        double ComputeGravitational() const 
        {
            // variable declarations  
            double G = 6.67 * 10e-11; 
            double F; 

            // code  
            F = (this->m1 * this->m2) / (this->r * this->r); 
            return (F); 
        }
}; 

int main(void) 
{
    // variable declarations 
    MassAndDistance EarthSun(1.9198e30, 5.9722e24, 149597871000); 
    MassAndDistance JupitorSun(1.9198e30, 1.89813e27, 76007000000); 
    double ForceBetweenEarthAndSun; 
    double ForceBetweenJupitorAndSun; 

    std::cout << "Force Between the Earth and the sun = " 
                << ForceBetweenEarthAndSun << " Newton" << endl; 
    std::cout << "Force between the Jupitor and the Sun = " 
                << ForceBetweenJupitorAndSun << " Newton" << endl; 
    
    return 0; 
} 

#include <iostream> 
#include <exception> 
#include <cmath> 

// class definition 
class MassAndDistance 
{
    private: 
        double m1; 
        double m2; 
        double r; 
    public:     
        MassAndDistance(double _m1, double _m2, double _r) 
        {
            if(_m1 <= 0.0 || _m2 <= 0.0 || _r <= 0.0)
                throw std::domain_error("Invalid input values"); 

            this->m1 = _m1; 
            this->m2 = _m2; 
            this->r = _r; 
        }

        double ComputeGravitational(MassAndDistance* pData) 
        {
            // variable declarations 
            double G = 6.67 * 10e-11; 
            double F; 

            // code 
            F = (G * this->m1 * this->m2) / (this->r * this->r); 
            return F; 
        }
}; 

int main(void) 
{
    // variable declarations 
    MassAndDistance EarthSun(1.9198e30, 5.9722e24, 149597871000); 
    MassAndDistance JupitorSun(1.9198e30, 1.8981e27, 76007000000); 
    double ForceBetweenEarthAndSun; 
    double ForceBetweenJupitorAndSun; 

    // code 
    ForceBetweenEarthAndSun = EarthSun.ComputeGravitational(&EarthSun); 
    ForceBetweenJupitorAndSun = JupitorSun.ComputeGravitational(&JupitorSun); 

    cout << "Force between the earth and the sun = " 
            << ForceBetweenEarthAndSun << " Newtin" << endl; 
    cout << "Force between the Jupitor and the sun = " 
            << ForceBetweenJupitorAndSun << " Newton" << endl; 
    
    return 0; 
}

// header file inclusion 
#include <stdio.h> 
#include <stdlib.h> 

// structure definition 
struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

// function declarations 
struct Date* createDateInstance(int _day, int _month, int _year); 
int getDay(struct Date* pDate); 
int getMonth(struct Date* pDate); 
int getYear(struct Date* pDate); 
void setDay(struct Date* pDate, int newDay); 
void setMonth(struct Date* pDate, int newMonth); 
void setYear(struct Date* pDate, int newYear); 
void showDate(struct Date* pDate); 
void releaseDateInstance(struct Date* pDate); 

// entry-point function 
int main(void) 
{
    return (0); 
}

struct Date* createDateInstance(int _day, int _month, int _year) 
{
    struct Date* newDate; 

    newDate= (struct Date*)malloc(sizeof(struct Date)); 
    if(newDate == NULL) 
    {
        fprintf(stderr, "Error in allocating memory"); 
        exit(-1); 
    }

    pDate->day = _day; 
    pDate->month = _month; 
    pDate->year = _year; 

    return (pDate); 
}

int getDay(struct Date* pDate) { return pDate->day; }
int getMonth(struct Date* pDate) { return pDate->month; }
int getYear(struct Date* pDate) { return pDate->year; }
void setDay(struct Date* pDate, int newDate) {
    pDate->day = newDay; 
}

void setMonth(struct Date* pDate, int newMonth) {
    pDate->month = newMonth; 
}

void setYear(struct Date* pDate, int newYear) {
    pDate->year = newYear; 
}

void showDate(struct Date* pDate) {
    printf("%d/%d/%d\n", pDate->day, pDate->month, pDate->year); 
}

void releaseDateInstance(sruct Date* pDate) {
    free(pDate); 
}

#include <iostream> 

// COMPANY: OBJECt 
struct MassAndDistance_1 
{
    double m1; 
    double m2; 
    double r; 
}; 

// COMPANy : product 
class MassAndDistance_2 
{
    double m1; 
    double m2; 
    double r; 
}

int main(void) 
{
    using std::cout; 
    using std::endl; 
    
    struct MassAndDistance_1 X1; 
    MassAndDistance_2 X2; 

    // CLIENT Accessing the internal member of the product he/she has brought 
    X1.m1 = 10.0; 
    X1.m2 = 20.0; 
    X1.r = 30.0; 

    X2.m1 = 1.1; // member not accessible 
    X2.m2 = 2.2; // member inaccessible 
    X2.r = 3.3; // member inaccessible 

    return 0; 
}

#include <iostream> 

// COMPANY 1 : PRODUCT 
struct MassAndDistance_1
{
    double m1; 
    double m2; 
    double r; 
}; 

class MassAndDistance_2 
{
    double m1; 
    double m2; 
    double r; 
}; 

int main(void) 
{
    using std::cout; 
    using std::endl; 

    struct MassAndDistance_1 X1; 
    MassAndDistance_2 X2; 

    X1.m1 = 10.0; 
    X1.m2 = 20.0; 
    X1.r = 30.0; 

    X2.m1 = 1.1; 
    X2.m2 = 2.2; 
    X2.r = 3.3; 

    return 0; 
}

#include <iostream> 

class Test 
{
    int a; 
    int b; 
    int c; 
    int d; 
    int e; 
}; 

int main(void)  
{
    Test t; 

    t.a = 10; 
    t.b = 20; 
    t.c = 30; 
    t.d = 40; 
    t.e = 50; 

    return 0; 
}

#include <stdio.h> 

struct Test 
{
    int a; 
    char b; 
    float c; 
}; 

void test_1(void); 
struct Test g_test_1; 

int main(void) 
{
    test_1(); 
    printf("g_tes_1.a = %d, g_test_1.b = %c, g_Test_1.c = %f\n", 
                g_test_1.a, g_test_1.b, g_test_1.c); 
    
    return (0); 
}

void test_1(void) 
{
    struct Test t1; 

    g_test_1.a = 100; 
    g_test_1.b = 'A'; 
    g_test_1.c = 1.1f; 

    t1.a = 200; 
    t1.b = 'B'; 
    t1.c = 6.38f; 

    printf("t1. = %d, t1.b = %c, t1.c = %f\n", t1.a, t1.b, t1.c); 
}

#include <iostream> 

using std::cout; 

class Test 
{
    int a; 
    char b; 
    float c; 
}; 

Test g_test_1; 

void test_1(void); 

int main(void) 
{
    test_1(); 
    return 0; 
}

void test_1(void) 
{
    Test t1; 

    g_test_1.a = 100;   // inaccessible 
    g_test_1.b = 'A';   // inaccessible 
    g_test_1.c = 1.1f;  // inaccessible 

    t1.a = 200; // CTE  
    t1.b = 'B'; // CTE
    t1.c = 6.38f; // CTE 
}

#include <iostream> 

using std::cout; 

class Test 
{
    private: 
        int a; 
    public:    
        char b; 
        float c; 
}; 

Test g_test_1; 
void test_1(void); 

int main(void) 
{
    test_1(); 
    return 0; 
}

void test_1(void) 
{
    Test t1; 

    g_test_1.a = 100; // error  
    g_test_1.b = 'B'; // ok 
    g_test_1.c = 1.1f; // ok 

    t1.a = 200; // error 
    t1.b = 'B'; // ok 
    t1.c = 3.3; // ok 
}

#include <iostream> 

struct Date 
{
    int day;    // data definition statment : allowed 
    int month;  // data definition statment : allowed 
    int year;   // data definition statment : allowed 

    // function definition statment : NOT allowed
    int get_day()
    {
        return (day); 
    }
}

#include <iostream> 

using std::cout; 

// stand alone function / global function / C like function 
int Compute(int x, int y); 

class Date 
{
    public: 
        int day; 
        int month; 
        int year; 

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }

        void show(date* pDate) 
        {
            cout << pDate->day << '/' << pDate->month << "/" << pDate->year << endl; 
        }

        // Every function written inside class date exist to process object of class date 
        // Every such function must accept address of date object
            // to undeerstand which object to be processed in current call 
}; 

class C 
{
    public: 
        void f(C* pC, /* optional other params */)
        { }

        void f()  // 'C* this' is automatically added  
        {} 
}; 

int main(void) 
{
    int result; 

    result = Compute(10, 5); 

    Date myBirthDate; 
    myBirthDate.day = 10; 
    myBirthDate.month = 7; 
    myBirthDate.year = 1986; 

    Date::show(&myBirthDate); 
}

int compute(int x, int y) 
{
    return (x+y) * (x-y); 
}

class Date 
{
    public: 
        int day; 
        int month; 
        int year; 

        void show() 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 

int main(void) 
{
    Date myBirthDate; 

    myBirthDate.day = 20; 
    myBirthDate.show(); 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    public: 
        int day; 
        int month; 
        int year; 

        void show() 
        {
            cout << "**** Enter Date::show() ****" << endl; 
            cout << "Address of date object used for making current call = " << this << endl; 
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
            cout << "**** LEAVE Date::show() ****" << endl; 
        }
}; 

int main(void) 
{
    // defining three local variables of Date 
    Date d1; 
    Date d2; 
    Date d3; 

    // define three pointers to class date 
    Date* pDate1 = 0; // pDate1 is a pointer to class Date 
    Date* pDate2 = 0; // pDate2 is a pointer to class Date 
    Date* pDate3 = 0; // pDate3 is a pointer to class Date 

    // set pointers to addresses 
    pDate1 = &d1; 
    pDate2 = &d2; 
    pDate3 = &d3; 

    // setting day, month, year of d1 
    pDate1->day = 10; 
    pDate1->month = 1; 
    pDate1->year = 2035; 

    // setting day month yeat of d2 
    pDate2->day = 1; 
    pDate2->month = 1; 
    pDate2->year = 1976; 

    // setting day month year of d3 
    pDate3->day = 1; 
    pDate3->month = 2; 
    pDate3->year = 2015; 

    cout << "main() : making use of pointer to call Date::show()" << endl; 
    cout << "main(): address of d1 : " << pDate1 << endl; 
    pDate1->show(); 

    cout << "main() : making use of pointer to call Date::show()" << endl; 
    cout << "main() : address of d2 : " << pDate2 << endl; 
    pDate2->show(); 

    cout << "main() : making use of pointer to call Date::show() " << endl; 
    cout << "main() : address of d3 : " << pDate3 << endl; 
    pDate3->show(); 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    public: 
        int day; 
        int month; 
        int year; 

        void show() 
        {
            cout << "***** Enter Date::Show() *****" << endl; 
            cout << "Address og object used for making the current call " << this << endl; 
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
            cout << "***** LEAVE Date::show() *****" << endl; 
        }
}; 

int main(void) 
{
    Date d1; 
    Date d2; 
    Date d3; 

    // setting day month year of d1 
    d1.day = 2; 
    d1.month = 2; 
    d1.year = 2025; 

    // setting day month year of d2 
    d2.day = 1; 
    d2.month = 1; 
    d2.year = 1970; 

    //  setting day month year of d3 
    d3.day = 24; 
    d3.month = 3; 
    d3.year = 2032; 

    cout << "main() : Making use of object d1 to call Date::show() " << endl; 
    cout << "main() : address of obect d1 = " << &d1 << endl; 
    d1.show(); 

    cout << endl; 
    cout << "main() : naking use of object d2 to call Date::show() " << endl; 
    cout << "main() : address of object d2 = " << &d2 << endl; 
    d2.show(); 

    cout << endl; 
    cout << "main() : making use of object d3 to call Date::show() " << endl; 
    cout << "main() : address of object d3 : " << &d3 << endl; 
    d3.show(); 

    return 0; 
}

#include <stdio.h> 

// server side start 
struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void show(struct Date* pDate); 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
}
// SERVER SIDE END 

// CLIENT SIDE START 
int main(void) 
{
    struct Date myDate = {8, 2, 2025}; 

    show(&myDate); 
    return (0); 
}
// CLIENT SIZE END 

class class class class throw this throw theow throe throw throw throw throw throw throuw throw throw throw throw 
====================================================== 10 MARCH 2025 ====================================================================================================================================================================================================
thrie throw throw theow throw throw throw throw throw thorow thorow throw throw throw throw throw theow thr;owthroe throw thrpw throw throw throw throw throw throw throw throw throw throw throw throw throw throwt thwor throw throw throw throw thwo 
#include <iostream> 
usng std::endl; 
using std::endl; 

// NAMEsPACE : it is  block for creating names 
// inside namespace x we can define folloeing names : 
// num, test, Date, xyz_t, Y 
namespace X {
    // data definition statiments 
    int num; 

    // function name statments 
    void test() 
    {
        cout << "Hello world!!!" << endl; 
    }

    // class 
    class Date 
    {
        private: 
            int day, month, year; 
        public: 
            Date() 
            {
                this->day = 1; 
                month = 1; 
                year = 1; 
            }

            void show() 
            {
                cout << day << "/" << month << "/" << year << endl; 
            }
    }; 

    // typedef 
    typedef int xyz_t; 

    // namespace 
    namespace Y 
    {
        int z; 
    }
}

class Test { 
public: 
    int num; // data member 
    static int snum; // static data member 

    // member function 
    void test_function(void) 
    {
        cout << "Inside Test::test()" << endl; 
    }

    // static member function 
    static void stest_function() 
    {
        cout << "Inside static test()" << endl; 
    }

    // typedef 
    typedef int data_t; 

    // class 
    class M {
        private: 
            int p, q, r; 
    }; 
}; 


// definiton of static variable snum inside class test 
int Test::snum = 100; 

void namespace_demo(void); 
void class_demo(void); 

int main(void) 
{
    namespace_demo(); 
    class_demo(); 
    return (0); 
}

void namespace_demo(void) 
{
    X::num; 
    X::test(); 
    X::Date day; 
    X::xyz_t num; 
    X::Y::p = 100; 
}

void class_demo(void) 
{
    Test::num; // not allowed 
    Test::test_function(); // not allowed 
    Test::snum = 500; // ok 
    Test::stest_function(); // ok 
    Test::pqr_t myNum = 600; // ok 
    Test::PQR myObject; // ok 
}

// X::Y 
1) if X is a namespace  then Y is : 
    .data variable .function name .typedef .nmesoace name .class 
2) if Y is a class 
    1) typedef name 2) static data member 3) static member function
    4) nested class 
    Y is available as per public-private rule 

#include <iostream> 

using std::endl; 
using std::cout; 

class Test 
{
    public: 
        int num;    // data variable name  
        static int snum;    // static data variable name 

        void test() 
        {
            cout << "in Date::test()" << endl; 
        } 

        static void stest_function() 
        {
            cout << "inside Test::stest_function()" << endl; 
        }

        typedef xyz_t; 

        class M {
            int p, q, r; 
        }
}; 

int Test::snum = 100; // definition of static variable snum inside class test 

namespace X {
    // data definition inside namespace 
    int num; 

    // function name inside namespacce 
    void test_func(void) 
    {
        cout << "Inside X::test_func()" << endl; 
    }

    // typedef inside namespace 
    typedef int xyz_t; 

    // class name inside namespace 
    class PQR {
        private: 
            int p, q, r; 
    }; 

    // namespace inside namespace 
    namespace Y {
        int num; 
    }
}

void namespace_demo(void); 
void class_demo(void); 

int main(void) 
{
    namespace_demo(); 
    class_demo(); 
    return 0; 
}

void namespace_demo(void) 
{
    X::num = 10; // ok 
    X::test_fun(); // ok 
    X::xyz_t num; // ok 
    X::PQR myObj; 
    X::Y::num = 10; // ok 
}

void class_demo(void) 
{
    Test::num; 
    Test::snum = 10; 
    Test::stest_func(); 
    Test::pqr_t vqr; 
    Test::PQR myObj; 
} 

// X::Y 
X is a namespace then 
Y can be - 1) data variable name 2) function name 3) typedef 
            4) namespace 5) class 
if X is a class then
Y can be - 1) static data member 2) static function member 
            3) typedef 4) nested class 
            Y is available as per public-private rule 

void test_func_1() 
{
    outer_loop : 
    for(int j = 0; j < 10; ++j) 
    {
        if(condition) 
            goto outer_loop; // highly undesirable unil writting very low level software 
    }
}

void test_func_1() 
{
    outer_loop: 
    for(int i = 0; i < 10; ++i) 
    {
        if(ccondition) 
            goto outer_loop; // highly undesirable until writting very low level software 
    }
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

int main(void) 
{
    string s2("ABCDE"); 
    string::iterator iter = s2.begin(); 

    cout << "*iter = " << *iter << endl; // *iter = 'A' 
    
    iter++; // advance internal current pointer to next char 
    cout << "*iter = " << *iter << endl; // *iter = 'B' 

    ++iter; // advance internal current pointer to nect char 
    cout << "*iter = " << *iter << endl; // *iter = 'C' 

    iter = iter+1; // advance internal current pointer to next char 
    cout << "*iter = " << *iter << endl; // *iter = 'D' 

    while(iter != s2.end()) 
    {
        cout << "*iter = " << *iter << endl; 
        ++iter; 
    }

    return (0); 
}

#include <iostream> 
#Include <string> 

using std::endl; 
using std::cout; 
using std::string; 

int main(void) 
{
    string s2("HELLO");
    string::iterator iter = s2.begin(); 

    cout << "*iter = " << *iter << endl; // *iter = 'H' 

    iter++; 
    cout << "*iter = " << *iter << endl; // *iter = 'E' 

    ++iter; 
    cout << "*iter = " << *iter << endl; 

    iter = iter + 1; 
    cout << "*iter = " << *iter << endl; 

    iter = s2.begin(); 
    while(iter != s2.end())
    {
        cout << "*iter = " << *iter << endl; 
        ++iter; 
    }

    return 0; 
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_iterator_demo(void); 

int main(void) 
{
    string_iterator_demo(); 
    return 0; 
}

void string_iterator_demo(void) 
{
    string s("HELLO"); 

    // 1 : using iterator and while loop 
    cout << "Repeat 1 : " << endl; 
    string::iterator my_iter = s.begin(); 
    while(my_iter != s.end()) 
    {
        cout << "Current char : " << *my_iter << endl; 
        ++my_iter; // pre-increment 
    }

    // 2 : using iterator and while loop 
    string::iterator iter_2 = s.begin(); 
    while(iter_2 != s.end()) 
    {
        cout << "current char : " << *iter_2 << endl; 
        iter_2++; // post increment  
    }

    // 3 : using iterator and while loop 
    string::iterator iter_3 = s.begin(); 
    while(iter_3 != s.end()) 
    {
        cout << "*iter_3 = " << *iter_3 << endl; 
    }

    string s2("CoreCode Programming Academy"); 
    
    // 1: using iterator and for loop  
    for(string::iterator iter_1 = s2.begin(); iter_1 != s2.end(); ++iter_1) 
    {
        cout << "*iter_1 = " << *iter_1 << endl; 
    }

    // 2: using iterator and for loop 
    for(string::iterator iter_2 = s2.begin(); iter_2 != s2.end(); iter_2++) 
    {
        cout << "*iter_2 = " << *iter_2 << endl; 
    }

    // 3: using iterator and for loop 
    for(string::iterator iterOfString = s2.begin(); iterOfString != s2.end(); iterOfString = iterOfString+1) 
    {
        cout << "*iterOfString = " << *iterOfString << endl; 
    }
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_iterator_demo(void); 

int main(void) 
{
    string_iterator_demo(); 
    return 0; 
}

void string_iterator_demo(void) 
{
    string s("Hello World!!!"); 

    // 1 : using iterator and while loop 
    cout << "Repeat 1 : " << endl; 
    string::iterator my_iter = s.begin(); 
    while(my_iter != s.end())
    {
        cout << "current char = " << *my_iter << endl; 
        ++my_iter; // pre-increment 
    }

    // 2 : using iterator and while loop 
    string::iterator iter_1 = s.begin(); 
    while(iter_1 != iter_1.end()) 
    {
        cout << "Current char : " << *iter_1 << endl; 
        iter_1++; // post-increment 
    }

    // 3 : using iterator and while loop 
    string::iterator iter_of_s = s.begin(); 
    while(iter_of_s != s.end()) 
    {
        cout << "*iter_of_s = " << *iter_of_s << endl; 
        iter_of_s = iter_of_s + 1; 
    }

    // 1 : for lopp 
    cout << "Repeat 1 using for loop " << endl; 
    for(string::iterator iter_2 = s.begin(); iter_2 != s.end(); ++iter_2) 
    {
        cout << "*iter_2 = " << *iter_2 << endl; 
    }
    // iter_2 not avaialable here 

    // 2: using for loop and iterator 
    cout << "Repeat 2 : using for loop and iterator" << endl; 
    for(string::iterator iterOfString = s.begin(); iterOfString != s.end(); iterOfString++) 
    {
        cout << "*iterOfString = " << *iterOfString << endl; 
    }

    // 3 : using for loop and iterator 
    cout << "Repea 3 using for loop : " << endl; 
    string strNameOfAcademy("CoreCode Programming Academy"); 
    for(
        string::iterator iterStr = strNameOfAcademy.begin(); 
        iterStr != strNameOfAcademy.end(); 
        ++iterStr   
    ) 
        cout << "*iterStr = " << *iterStr << endl; 
}

#include <stdio.h> 

using std::cout; 
using std::endl; 

class Date 
{
    public: 
        typedef int day_t; 
        typedef int month_t; 
        typedef int year_t; 
    private: 
        day_t day; 
        month_t month; 
        year_t year; 
    public: 
        Date(day_t day, month_t month, year_t year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        day_t get_day() 
        {
            return day; 
        }

        month_t get_month() 
        {
            return month; 
        }

        year_t get_year() 
        {
            return year; 
        }
}; 

int main(void) 
{
    Date myDate(15, 2, 2025); 
    Date::day_t day = myDate.get_day(); // Date::get_day(&myDate); 
    Date::month_t month = myDate.get_month(); // Date::get_month(&myDate); 
    Date::year_t year = myDate.get_year(); // Date::get_year(&myDate) 

    cout << day << "/" << month << "/" << year << endl; 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date {
    public: 
        typedef int day_t; 
        typedef int month_t; 
        typedef int year_t; 
    private: 
        int day, month, year; 
    public: 
        Date(day_t init_day, month_t month, year_t year) 
        {
            day = init_day; 
            month = init_month; 
            year = init_year; 
        }

        day_t get_day() 
        {
            return day; 
        }

        month_t get_month() 
        {
            return month; 
        }

        year_t get_year() 
        {
            return year; 
        }
}; 

int main(void) 
{
    Date myDate(12, 12, 2012); 

    day_t day = myDate.get_day; // Date::get_day(&myDate); 
    month_t month = myDate.get_month(); // Date::get_month(&myDate); 
    year_t year = myDate.get_year(); // Date::get_year(&myDate); 

    cout << day << "/" << month << "/" << year << endl; 
}

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_demo(void); 
void vector_demo(void); 

int main(void) 
{
    string_demo(); 
    vector_demo(); 
    return 0; 
}

void string_demo(void) 
{
    string s1; 
    string s2("Hell0"); 
    string s3(s2); 

    cout << "STRING DEMO ENTER --------------------------" << endl; 
    cout << "s1 : " << s1 << endl;  // empty 
    cout << "s2 : " << s2 << endl; 
    cout << "s3 : " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 
    cout << "Contents of s2 and s3 are same but addresses are not"  
            << "this proves that s2 is a clone of s2" << endl; 

    cout << "Show a string char by char : " << endl; 
    cout << "METHOD 1 : index by index --------------------------" << endl; 

    for(string::size_type i = 0; i != s2.size(); i++) 
        cout << "s2[" i << "] = " << s2[i] << endl; 
    cout << "METHOD 1 ENDS" << endl; 

    cout << "METHOD 2 : Using iterator" << endl; 
    for(string:iterator iter = s2.begin(); iter != s2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 
    cout << "METHOD 2 END " << endl; 
    cout << "STRING_DEMO LEAVE -----------------------------------------------" << endl; 
} 

void vector_demo(void) 
{} 

#include <iostream> 
#include <string> 

using std::cout; 
using std::endl; 
using std::string; 

void string_demo(void); 

int main(void) 
{
    string_demo(); 
    return 0; 
}

void string_demo(void) 
{
    string s1; 
    string s2("Sarthak Jaiswal"); 
    string s3(s2); 

    cout << "---------------- STRING DEMO ENTER --------------" << endl; 
    cout << "s1 : " << s1 << endl; 
    cout << "s2 : " << s2 << endl; 
    cout << "s3 : " << s3 << endl; 
    cout << "addr(s2) : " << &s2 << endl; 
    cout << "addr(s3) : " << &s3 << endl; 
    cout << "Contents of s2 and s3 are same but addresses are not" 
            << "this preoves that s3 is a clone of s2" << endl; 

    cout << "Show a string char by char : " << endl; 
    cout << "METHOD 1 : Using Index: " << endl; 

    for(string::size_type i = 0; i != s2.size(); i++) 
        cout << "s2[" << i << "] = " << s2[i] << endl; 
    cout << "------------ METHOD 1 ENDS -----------------" << endl; 

    cout << "METHOD 2: Using iterator" << endl; 
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter) 
        cout << "*iter = " << *iter << endl; 
    cout << "----------- METHOD 2 ENDS ------------" << endl; 
    cout << "STRING DEMO LEAVE" << endl; 
}

#include <stdio.h> 

using std::cout; 
using std::endl; 

int get_roll_number(); 
double get_sal(); 
char* get_addr(); 

// good practise 
typedef int roll_number_t; 
typedef double salary_t;
typedef char* addr_t; 

void test_function(void); 

int main(void) 
{
    int x;  // x is a roll number 
    int y;  // y is a salary 
    char* s;    // s is an address 
    
    // recommended practise 
    int roll_number; 
    double employee_salary; 
    char* address_of_student; 

    return 0; 
}

void test_function(void) 
{
    roll_number_t get_roll_numbet(void); 
    salary_t get_salary(void); 
    addr_t get_address(void); 
    
    roll_number_t roll_number; 
    salary_t salary_of_employee; 
    addr_t address_of_student; 

    roll_number = get_roll_number(); 
    salary_of_employee = get_salary(); 
    address_of_student = get_address(); 
}

#include <stdio.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

int main(void) 
{
    int num = 10; 
    printf("num = %d\n", num); // 10 will be printed 

    struct Date myDate = {9, 2, 2025}; 
    printf("%d-%d-%d\n", myDate.day, myDate.month, myDate.year); 
    //  9, 2, 2025 will be printed 

    return 0; 
}

#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public: 
        void init(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() 
        {
            cout << this->day << "/ " 
                    << this->month << "/" 
                    << this->year << endl; 
        } 
}; 

int main(void) 
{
    int num = 100; 
    cout << "num = " << num << endl; // 100 

    Date myDate; // there is no way as of now to initialize an object 
                 // we can add init() function to class 
    myDate.init(9, 2, 2025); 

    // add show() function 
    myDate.show(); // 9, 2, 2025 

    return 0; 
}

// At c++ syntax level 
// allocate of memory to Date object is done by 
// Date myDate 

// setting value for the first time is done by 
// myDate.init(9, 2, 2025) 

// There are two separate steps and therefore do not come under category of initialization 
// If we could so something like Date myDate(9, 2, 2025) 
// then it would come under initialization 

// Date myDate(9, 2, 2025) 
// After reading this, C++ compiler should allocate block of memory for 
// myDate object and INTERNALLY call Date::init(). 
#include <iostream> 

using std::cout; 
using std::endl; 

class Date 
{
    private: 
        int day; 
        int month; 
        int year; 
    public: 
        // CONSTRUCTOR FUNCTION 
        Date(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        void show() 
        {
            cout << day << "/" << month << "/" << year << endl; 
        }
}; 

int main(void) 
{
    Date myDate(9, 2, 2025); 
    // 12 bytes of memory block will be allocated to Date object 
    // Make call to Date::Date(addr_of_new_object, 9, 2, 2025) 
    myDate.show(); // Date::show(&myDate); 

    return 0; 
}

#include <iostream> 
#include <cstdlib.h> 

using std::cout; 
using std::endl; 

class MassAndDistance 
{
    private: 
        double m1; 
        double m2; 
        double r; 
    public: 
        MassAndDistance(double _m1, double _m2, double _r) 
        {
            this->m1 = _m1; 
            this->m2 = _m2; 
            this->r = _r; 
        }

        double ComputeGravitational() 
        {
            double G = (6.67 * 10e-11); 
            double F; 

            if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
            {
                cout << "Invalid values for mass and/or distance" << endl; 
                cout << "Exitting the application..." << endl; 
                exit(-1); 
            }

            F = (G * m1 * m2) / (r * r); 
            return F; 
        }
}; 

int main(void) 
{
    MassAndDistance sunEarth(1.9198e20, 5.9722e24, 149597871000); 

    cout << "Gravitational force of attraction between the Sun and the Earth = " 
            << sunEarth.computeGravitational() << endl; 

    return 0; 
}

#include <iostream> 
#include <cstdlib> 

using std::endl; 
using std::cout; 

class MassAndDistance 
{
    private: 
        double m1; 
        double m2; 
        double r; 

    public: 
        MassAndDistance(double _m1, double _m2, double _r) 
        {
            this->m1 = _m1; 
            this->m2 = _m2; 
            this->r = _r; 
        }

        double computeGravitational() 
        {
            double G = (6.67 * 10e-11); 
            double F; 

            if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
            {
                cout << "Invalid values for mass and/or distance" << endl; 
                cout << "Exitting the application..." << endl; 
                exit(-1); 
            }

            F = (G * m1 * m2) / (r * r); 
            return F; 
        }
}; 

int main(void) 
{
    MassAndDistance sunEarth(1.9198e30, 5.9722e24, 149597871000); 

    cout << "Gravitational force of attraction between the Sun and the Earth = "    
            << sunEarth.computeGravitational() << endl; 

    return 0; 
}

#include <iostream> 

class Test 
{
    private: 
        int a; 
        char b; 
        float c; 
    public: 
        int d; 
        int e; 
        int f; 
}; 

// Qualified access 
// Test_object.a, Test_object.b, test_object.c 
// Test_ptr->a, test_ptr->b, test_ptr->c 

int main(void) 
{
    Test t1; 
    Test t2; 

    // CTE 
    t1.a = 10; 
    t1.b = 'b'; 
    t1.c = 3.41; 

    // ok 
    t1.d = 100; 
    t1.e = 200; 
    t1.f = 300; 
}

#include <iostream> 
using std::cout; 
using std::endl; 
class Date 
{
    int day; 
    int month; 
    int year; 

    void show(Date* pDate) 
    {
        cout << pDate->day << "/" << pDate->month << "/" << pDate->year << endl; 
    }
}; 

int main(void) 
{
    Date myDate; // day month year 
    Date d1;        // day month year 

    myDate.day = 8; 
    myDate.month = 2; 
    myDate.year = 2025; 

    d1.day = 11; 
    d1.month= 3; 
    d1.year = 2026; 

    Date::show(&myDate); 
    Date::show(&d1); 
}

class C 
{
    public: 
        // f() exist to algorithmically process an object of class C 
        void f(void) 
        {
            // which object of class C will we process in current call of C::f()? 
        }
}; 

class YourClassName 
{
    private: 
        int a; 
        char b; 
        float c; 
    public: 
        // YourClassName* this : first formal parameter
        void YourFunctionName(int m, int n) 
        {
            this->data_member; 
            this->member_function; 

            this->a 
            this->b 
            this->c 

            m // direct access to formal parameters 
            n // direct access to formal parameters 
        }
}; 

int main(void) 
{
    YourClassName YourObjectName; 

    YourClassName::YourFunctionName(&YourObjectName, 10, 20); 
    
    YourClassName.YourFunctionName(10, 20); 
}

#include <stdio.h> 

// server side start 
struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void show(struct Date* pDate) 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year) 
}
// server side end 

// client side start 
int main(void) 
{
    struct Date myDate = {8, 2, 2025}; 

    show(&myDte); 
    return (0); 
}
// client side end 

#include <iostream> 

using std::cout; 
using std::endl; 

// server side start 
class Date 
{
    private: 
        int day, month, year; 
    public: 
        void show() 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 
// server side end 

// client side start 
int main(void) 
{
    // day month and year of myDate will contain garbage values 
    Date myDate; 

    myDate.show(); // Date::show(&myDate) 

    return (0); 
}
// client side end 

// header file inclusion 
#include <iostream> 

// importing symbols 'cout' and 'endl' from standard namespace 
using std::cout; 
using std::endl; 

// server-side start 
class Date 
{
    private: 
        // data layout definition 
        int day;
        int month; 
        int year; 
    public: 
        // public member function 
        // REMEMBER -> first parameter of init() function is Date* this 
        void init(int init_day, int init_month, int init_year) 
        {
            this->day = init_day; 
            this->month = init_month; 
            this->year = init_year; 
        }

        // remeber -> first parameter of show() is Date* this 
        void show() 
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl; 
        }
}; 
// server side end 

// client side start 
int main(void)
{
    // create an instance of class Date 
    Date myDate; 

    // use of object class Date 
    cout << "myDate befire calling init() function on it" << endl; 
    myDate.show(); // Date::show(&myDate); 
    myDate.init(8, 2, 2025); 
    cout << "myDate after calling init() function on it" << endl; 
    myDate.show(); 

    return 0; 
}

==================== 19 MARCH 2025 ===================================================================================================================
#include <stdio.h> 
#Include <stdlib.h> 

void fill_array(int* p, size_t N); 
void show_array(int* p, size_t N); 

int main(void) 
{
    int* p_arr = NULL; 
    size_t N = 0; 

    p_arr = (int*)malloc(N * sizeof(int)); 
    if(p_arr == NULL) 
    {
        puts("Error in allocating memory"); 
        exit(EXIT_FAILURE); 
    }

    fill_array(p_arr, N); 
    show_array(p_arr, N); 

    free(p_arr); 
    p_arr = NULL; 

    return (0); 
}

void fill_array(int* p_arr, size_t N) 
{
    size_t i = 0; 

    for(i = 0; i < N; ++i) 
        *(p+i) = (i+1) * 100; 
}

void show_array(int* p_arr, size_t N) 
{
    size_t i; 

    for(i = 0; i < N; ++i) 
        printf("*(p + %d) = %d\n", i, *(p_arr+i)); 
}

#include <stdio.h> 
#include <stdlib.h> 

void show_array(int* p, size_t N); 
void fill_array(int* p, size_t N); 

int main(void) 
{
    int* p_arr = NULL; 
    size_t N = 3; 

    p_arr = (int*)malloc(N * sizeof(int)); 
    if(p_arr == NULL) 
    {
        printf("Error in allocating memory"); 
        exit(EXIT_FAILURE); 
    }

    fill_array(p_arr, N); 
    show_array(p_arr, N); 

    free(p_arr);
    p_arr = NULL; 

    return (0); 
}

void show_array(int* p, size_t N)
{
    size_t i = 0; 

    for(i = 0; i < N; ++i) 
        printf("*(p+%d) = %d\n", i, *(p+i)); 
}

void fill_array(int* p, size_t N) 
{
    size_t i; 

    for(i = 0; i < N; ++i) 
        *(p+i) = (i+1) * 100; 
}

#include <stdio.h> 
#include <stdlib.h> 

int* get_array(int* pN); 

int main(void) 
{
    int* p = 0; 
    int N = -1; 
    int i; 

    p = get_array(&N); 

    /* fill_array() */
    for(i = 0; i < N; ++i) 
        *(p + i) = (i + 1) * 100; 

    /* show_array() */
    for(i = 0; i < N; ++i) 
        printf("*(p + %d) = %d\n", i, *(p+i)); 

    free(p); 
    p = NULL; 

    return (0); 
}

int* get_array(int* pN) 
{
    int* p = NULL; 
    int N; 

    printf("Enter array size : "); 
    scanf("%d", &N); 

    if(N <= 0) 
    {
        puts("Array size must be positive"); 
        exit(-1); 
    }

    p = (int*)malloc(N * sizeof(int)); 
    if(p == NULL) 
    {
        puts("Error in allocating memory"); 
        exit(-1); 
    }

    *pN = N; 
    return (p); 
}

#include <stdio.h> 
#include <stdlib.h> 

int* get_array(int* pN); 

int main(void) 
{
    int* p_arr = NULL; 
    int N = -1; 
    int i; 

    p_arr = get_array(&N); 

    // fill_array() 
    for(i = 0; i < N; ++i) 
        *(p + i) = (i + 1) * 100; 

    // show_array() 
    for(i = 0; i < N; ++i) 
        printf("*(p + %d) = %d\n", i, *(p + i)); 

    free(p_arr);
    p_arr = NULL; 

    return (0); 
}

int* get_array(int* pN) 
{
    int* p_arr = NULL; 
    int N; 

    printf("Enter array size : "); 
    scanf("%d", &N); 

    if(N <= 0) 
    {
        printf("Array size must be positive "); 
        exit (-1); 
    }

    p_arr = (int*)malloc(N * sizeof(int)); 
    if(p_arr == NULL) 
    {
        puts("Error in allocating memory"); 
        exit (-1); 
    }

    *pN = N; 
    return (p_arr); 
}

#include <stdio.h> 
#Include <stdlib.h> 

void get_array(int** pp_arr, int* pN); 
void fill_array(int* p_arr, int N); 
void show_array(int* p_arr, int N); 
void release_array(int** pp_arr); 

int main(void) 
{
    int* p_arr = NULL; 
    int N = -1; 

    get_array(&p_arr, &N); 
    fill_array(p_arr, N); 
    show_array(p_arr, N); 
    release_array(&p_arr); 

    return (0); 
}

void get_array(int** pp_arr, int* pN) 
{
    int* p = NULL; 
    int N = -1; 

    printf("Enter size of array : "); 
    scanf("%d", &N); 

    if(N <= 0) 
    {
        printf("array size must be positive"); 
        exit(-1); 
    }

    p = (int*)malloc(N * sizeof(int)); 
    if(p == NULL) 
    {
        printf("Error in allocating memory"); 
        exit(-1); 
    }

    *pp_arr = p; 
    *pN = N; 
}

void fill_array(int* p_arr, int N) 
{
    int i; 

    for(i = 0; i < N; ++i) 
        *(p + i) = (i+1) * 100; 
}

void show_array(int* p_arr, int N) 
{
    int i; 

    for(i = 0; i < N; ++i) 
        printf("*(p + %d) = %d\n", i, *(p+i)); 
}

void release_array(int** pp_arr) 
{
    free(*pp_arr); 
    *pp_arr = NULL; 
}

#include <stdio.h> 
#include <stdlib.h> 

void get_array(int** pp_arr, int* pN); 
void fill_array(int* p, int N);
void show_array(int* p, int N); 
void release_array(int** pp_arr); 

int main(void) 
{
    int* arr = NULL; 
    int N = -1; 

    get_array(&arr, &N); 
    fill_array(arr, N); 
    show_array(arr, N); 
    release_array(&arr); 

    return (0); 
}

void get_array(int** pp_arr, int* pN) 
{
    int* p = NULL; 
    int N = -1; 

    printf("Enter array size : "); 
    scanf("%d", &N); 

    p = (int*)malloc(N * sizeof(int)); 
    if(p == NULL) 
    {
        printf("Error in allocating memory"); 
        exit (-1); 
    }

    *pp_arr = p; 
    *pN = N; 
}

void fill_array(int* p_arr, int N) 
{
    int i; 

    for(i = 0; i < N; ++i) 
        *(p + i) = (i + 1) * 100; 
}

void show_array(int* p_arr, int N) 
{
    int i; 

    for(i = 0; i < N; ++i) 
        printf("*(p = %d) = %d\n", i, *(p + i)); 
}

void release_array(int** pp_arr) 
{
    free(*pp_arr); 
    *pp_arr = NULL; 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

// pDate is an IN parameter 
void show_date(struct Date* pDate); 

int main(void) 
{
    struct Date exam_date = {1, 2, 2023}; 
    struct Date* p_result_date = 0; 

    p_result_date = (struct Date*)malloc(sizeof(struct Daete)); 
    if(p_result_date == NULL) 
    {
        puts("Error in allocating memory"); 
        exit(-1); 
    }

    p_result_date->day = 30; 
    p_result_date->month = 3; 
    p_result_date->year = 2023; 

    show_date(&exam_date); 
    show_date(p_result_date); 

    free(p_result_date); 
    p_result_date = 0; 

    return (0); 
}

void show_date(struct Date* pDate) 
{
    printf("%d/%d/%d\n", pDate->day, pDate->month, pDate->year); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

// pDate is an IN Parameter 
void show_date(struct Date* pDate); 

int main(void) 
{
    struct Date exam_date = {1, 2, 2023}; 
    struct Date* result_date = NULL; 

    p_result_date = (struct Date*)malloc(sizeof(struct Date)); 
    if(p_result_date == NULL) 
    {
        printf("Error in allocating memory"); 
        exit (-1); 
    }

    p_result_date->day = 30; 
    p_result_date->month = 3; 
    p_result_date->year = 2023; 

    show_date(&exam_date); 
    show_date(p_result_date); 

    return (0); 
}

void show_date(struct Date* p_date) 
{
    printf("%d-%d-%d\n", p_date->day, p_date->month, p_date->year); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

// pDate is a IN parameter 
void show_date(struct Date* pDate); 

int main(void) 
{
    struct Date exam_date = {1, 2, 2023}; 
    struct Date* result_date = NULL; 

    result_date = (struct Date*)malloc(sizeof(struct Date)); 
    if(result_date == NULL) 
    {
        puts("Error in allocating memory"); 
        exit(-1); 
    }

    result_date->day = 1; 
    result_date->month = 3; 
    result_date->year = 2023; 

    show_date(&exam_date); 
    show_date(p_result_date); 

    free(p_result_date); 
    p_result_date = NULL; 

    return (0); 
}

void show_date(struct Date* pDate) 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void show_date(struct Date* pDate); 

int main(void) 
{
    struct Date exam_date = {1, 2, 2023}; 
    struct Date* result_date = NULL; 

    result_date = (struct Date*)malloc(sizeof(struct Date)); 
    if(result_date == NULL) 
    {
        printf("Error in allocating memory"); 
        exit (-1); 
    }

    result_date->day = 1; 
    result_date->month = 3; 
    result_date->year = 2023; 

    show_date(&exam_date); 
    show_date(p_result_date); 

    return (0); 
}

void show_date(struct Date* pDate) 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void initialize_date(struct Date* pDate, int init_day, int init_month, int init_year); 
void show_date(struct Date* pDate); 

int main(void) 
{
    struct Date exam_date; 
    struct Date* p_result_date = NULL; 

    initialize_date(&exam_date, 1, 2, 2023); 
    initialize_date(&result_date, 30, 3, 2023); 

    show_date(&exam_date);
    show_date(p_result_date); 

    free(p_result_date); 
    p_result_date = NULL; 

    return (0); 
}

void initialize_date(struct Date* pDate, int init_day, int init_month, int init_year) 
{
    pDate->day = init_day; 
    pDate->month = init_month; 
    pDate->year = init_year; 
}

void show_date(struct Date* pDate) 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void initialize_date(struct Date* pDate, int init_day, int init_month, int init_year); 
void show_date(struct Date* pDate); 

int main(void) 
{
    struct Date exam_date; 
    struct Date* result_date; 

    result_date = (struct Date*)malloc(sizeof(struct Date)); 
    if(result_date == NULL) 
    {
        printf("Error in allocating memory"); 
        exit(-1); 
    }

    initialize_date(&exam_date, 1, 3, 2023); 
    initialize_date(p_result_date, 30, 3, 2023); 

    show_date(&exam_date); 
    show_date(p_result_date); 

    free(p_result_date); 
    p_result_date = NULL; 

    return (0); 
}

void initialize_date(struct Date* pDate, int init_day, int init_month, int init_year) 
{
    pDate->day = init_day; 
    pDate->month = init_month; 
    pDate->year = init_year; 
}

void show_date(struct Date* pDate) 
{
    printf("%d/%d/%d\n", pDate->day, pDate->month, pDate->year); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

struct Date* get_date(void); 

int main(void) 
{
    struct Date* pDate = NULL; 

    pDate = get_date(); 
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
    free(pDate); 
    pDate = NULL; 

    return (0); 
}

struct Date* get_date(void) 
{
    struct Date* pDate = NULL; 
    int day, month, year; 

    printf("Enter day : "); 
    scanf("%d", &day); 

    printf("Enter month : "); 
    scanf("%d", &month); 

    printf("Enter year : "); 
    scanf("%d", &year); 

    pDate = (struct Date*)malloc(sizeof(struct Date)); 
    if(pDate == NULL) 
    {
        puts("Error in allocating memory"); 
        exit(-1); 
    }

    pDate->day = day; 
    pDate->month = month; 
    pDate->year = year; 

    return (pDate); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

struct Date* get_date(void); 

int main(void) 
{
    struct Date* p = NULL; 

    p = get_date(); 
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 

    free(p); 
    p = NULL; 

    return (0); 
}

struct Date* get_date(void) 
{
    struct Date* pDate = NULL; 
    int day, month, year; 

    printf("Enter day : "); 
    scanf("%d", &day); 

    printf("Enter month : "); 
    scanf("%d", &month); 

    printf("Enter year : "); 
    scanf("%d", &year); 

    pDate = (struct Date*)malloc(sizeof(struct Date)); 
    if(pDate == NULL) 
    {
        printf("Error in allicating memory"); 
        exit(-1); 
    }

    pDate->day = day; 
    pDate->month = month; 
    pDate->year = year; 

    return (pDate); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void get_date(struct Date** pp_date); 
void show_date(struct Date* pDate); 
void release_date(struct Date** pp_date); 

int main(void) 
{
    struct Date* pDate = 0; 

    get_date(&pDate); 
    show(pDate); 
    release_date(&pDate); 

    return (0); 
}

void get_date(struct Date** ppDate) 
{
    struct Date* pDate = NULL; 
    int day, month, year; 

    printf("Enter day : "); 
    scanf("%d", &day); 

    printf("Enter month : "); 
    scanf("%d", &month); 

    printf("Enter year : " ); 
    scanf("%d", &year); 

    pDate = (struct Date*)malloc(sizeof(struct Date)); 
    if(pDate == NULL) 
    {
        pDate->day = day; 
        pDate->month = month; 
        pDate->year = year; 
    }

    *ppDate = pDate; 
}

void show_date(struct Date* pDate) 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
}

void release_date(struct Date** ppDate) 
{
    free(*ppDate); 
    *ppDate = NULL; 
}

#include <stdio.h> 
#include <stdlib.h> 

void get_date(struct Date** ppDate); 
void show_date(struct Date* pDate); 
void release_date(struct Date** ppDate); 

int main(void) 
{
    struct Date* p = NULL; 

    get_date(&p); 
    show_date(p); 
    release_date(&p); 

    return (0); 
}

void get_date(struct Date** ppDate) 
{
    struct Date* pDate = NULL; 
    int day, month, year; 

    printf("Enter day : "); 
    scanf("%d", &day); 

    printf("Enter month : ");
    scanf("%d", &month); 

    printf("Enter year : "); 
    scanf("%d", &year); 

    pDate = (struct Date*)malloc(sizeof(struct Date)); 
    if(pDate == NULL)
    {
        puts("Error in allocating memory"); 
        exit(-1); 
    }

    pDate->day = day; 
    pDate->month = month; 
    pDate->year = year; 

    *ppDate = pDate; 
}

void show_date(struct Date* pDate) 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
}

void release_date(struct Date** pDate) 
{
    free(*ppDate); 
    *ppDate = NULL; 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void get_date(struct Date** ppDate); 
void show_date(struct Date* pDate); 
void release_date(struct Date** ppDate); 

int main(void) 
{
    struct Date* pDate = NULL; 

    get_date(&pDate); 
    show_date(pDate): 
    release_date(&pDate); 

    return (0); 
}

void get_date(struct Date* ppDate) 
{
    struct Date* pDate = NULL;
    int day, month, year; 

    printf("Enter day : "); 
    scanf("%d", &day); 

    printf("Enter month : "); 
    scanf("%d", &month); 

    printf("Enter year : "); 
    scanf("%d", &year); 

    pDate = (struct Date*)malloc(sizeof(struct Date)); 
    if(pDate == NULL) 
    {
        printf("Error in allocating memory"); 
        exit(-1); 
    }

    pDate->day = day; 
    pDate->month = month; 
    pDate->year = year; 

    *ppDate = pDate; 
}

void show_date(struct Date* pDate) 
{
    printf("%d-%d-%d\n", pDate->day, pDate->month, pDate->year); 
}

void release_date(struct Date** ppDate) 
{
    free(*ppDate); 
    *ppDate = NULL; 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

int main(void) 
{
    struct Date d_arr[5]; 
    int i; 

    for(i = 0; i < 5; ++i) 
    {
        d_arr[i].day = i+1; 
        d_arr[i].month = 10-i; 
        d_arr[i].year = 2020+i; 
    }

    for(i = 0; i < 5; ++i) 
    {
        printf("Date at index %d is %d-%d-%d\n", 
                i, d_arr[i].day, d_arr[i].month, d_arr[i].year); 
    }

    return (0); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

int main(void) 
{
    struct Date d_arr[5]; 
    int i; 

    for(i = 0; i < 5; ++i) 
    {
        d_arr[i].day = i+1; 
        d_arr[i].month = 10-i; 
        d_arr[i].year = 2020+i; 
    }

    for(i = 0; i < 5; ++i) 
    {
        printf("Date at index %d is %d-%d-%d\n", 
            i, pDate[i].day, pDate[i].month, pDate[i].year); 
    }

    return (0); 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void init_array(struct Date* pDate_att, size_t N); 
void show_array(struct Date* pDate_arr, size_t N); 

int main(void) 
{
    struct Date* pDate_arr = NULL; 
    size_t N = 5; 

    pDate_arr = (struct Date*)malloc(N * sizeof(struct Date)); 
    if(pDate_arr == NULL) 
    {
        puts("Error in allocating memory"); 
        exit(-1); 
    }

    init_array(pDate_arr, N); 
    show_array(pDate_arr, N); 

    free(pDate_arr); 
    pDate_arr = NULL; 

    return (0); 
}

void init_array(struct Date* pDate_att, size_t N) 
{
    size_t i; 

    fo(i = 0; i < N; ++i) 
    {
        pDate_arr[i].day = 20; 
        pDate_arr[i].month = 10-i; 
        pDate_arr[i].year = 2020+i; 
    }
} 

void show_array(struct Date* pDate_arr, size_t N) 
{
    size_t i; 

    for(i = 0; i < N; ++i) 
        printf("Date at index %d = %d-%d-%d\n", 
            i, pDate_arr[i].day, pDate_arr[i].month, pDate_arr[i].year); 
} 

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day; 
    int month; 
    int year; 
}; 

void init_array(struct Date* pDate_array, size_t N); 
void show_array(struct Date* pDate_array, size_t N); 

int main(void) 
{
    struct Date* pDate_arr = NULL; 
    size_t N = 5; 

    pDate_arr = (struct Date*)malloc(N * sizeof(pDate_arr)); 
    if(pDate_arr == NULL) 
    {
        printf("Error in allocating memory"); 
        exit(-1); 
    }

    init_array(pDate_arr, N); 
    show_array(pDate_arr, N); 

    free(pDate_arr); 
    pDate_arr = NULL; 

    return (0); 
}

void init_array(struct Date* pDate_array, size_t N) 
{
    size_t i = 0; 

    for(i = 0; i < N; ++i) 
    {
        pDate_arr[i].day = 20+i; 
        pDate_arr[i].month = 10-i; 
        pDate_arr[i].year = 2020+i; 
    }
}

void show_array(struct Date* pDate_arr, size_t N) 
{
    size_t i; 

    for(i = 0; i < N; ++i) 
        printf("Date at index %d = %d/%d/%d\n", 
            i, pDate_arr[i].day, pDate_arr[i].month, pDate_arr[i].year); 
}

=========================================== 03 APRIL 2025 =============================================================
/* STAGE 1 : Using procedural programming : USING BUITIN FUNCTIONS */

#include <stdio.h>
#include <stdlib.h> 

int main(void) 
{
    double G = 6.67*10e-11; /* Universal Gravitational constant */
    double m1;  /* for storing mass of object 1 in kgs */
    double m2;  /* for storing mass of object 2 in kgs */
    double r;   /* for storing distance between the obejcts in meters */
    double F;  /* for storing gravitational force in newtons */

    printf("Enter mass of object 1 in kgs : "); 
    scanf("%lf", &m1); 

    printf("Enter mass of object 2 in kgs : "); 
    scanf("%lf", &m2); 

    printf("Enter distance between the objects in meters : "); 
    scanf("%lf", &r); 

    if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
    {
        printf("Invalid values for mass and/or ditance.\n"); 
        exit(-1); 
    }

    F = (G * m1 * m2) / (r * r); 

    printf("Force of gravitation = %lf Newton\n", F); 

    return (0); 
}

/* stage 2 : object based programming in c++ : using builtin obejcts */
#include <iostream> 

int main(void) 
{
    using std::cout; // ostream : std::ostream 
    using std::cin;  // istream : std::istream 

    double G = 6.67 * 10e-11; // universal gravitational constant 
    double m1a;  /* for storing mass of object 1 in kgs */
    double m2a;  /* for storing madd of obejct 2 in kgs */
    double ra;   /* for storing distance between the objects in meters */
    double Fa;   /* for storing force in Newton */

    double m1b; 
    double m2b; 
    double rb; 
    double Fb; 

    cout << "Enter mass of object 1 in kgs : "; 
    cin >> m1a; 

    cout << "Enter mass of object 2 in kgs : "; 
    cin >> m2a; 

    cout << "Enter distance between the objects in meters : "; 
    cin >> ra; 

    if(m1a <= 0.0 || m2a <= 0.0 || ra <= 0.0) 
    {
        cout << "Invalid values for mass and/or distance\n"; 
        exit(-1); 
    }

    Fa = (G * m1a * m2a) / (ra * ra); 

    std::cout << "Force of gravitation = " << Fa << " Newton\n"; 

    cout << "Enter mass of object 1 in kgs : "; 
    cin >> m1b; 

    cout << "Enter mass of object 2 in kgs : "; 
    cin >> m2b; 

    cout << "Enter distance between the objects in meters : "; 
    cin >> rb; 

    if(m1b <= 0.0 || m2b <= 0.0 || rb <= 0.0) 
    {
        cout << "Invalid values for mass and/or distance\n"; 
        exit(-1); 
    }

    Fb = (G * m1b * m2b) / (rb * rb); 

    cout << "Force of gravitation = %lf" << Fb << " Newton\n"; 

    return (0); 
}

/* STAGE 3 : PROCEDURAL PROGRAMMING IN C USING STRUCT */
#include <stdio.h> 
#include <stdlib.h> 

struct MassAndDistance 
{
    double m1; 
    double m2; 
    double r; 
}; 

double ComputeGravitationalForce(struct MassAndDistance* pData); 

int main(void) 
{
    struct MassAndDistance sunEarth; 
    struct MassAndDistance sunJupitor; 
    double ForceBetweenSunAndEarth; 
    double ForceBetweenSunAndJupitor; 

    sunEarth.m1 = 1.9198e30; // mass of sun 
    sunEarth.m2 - 5.9722e24; // mass of earth 
    sunEarth.r = 149597871000; // distance between them 
    ForceBetweenSunAndEarth = ComputeGravitationalForce(&sunEarth); 
    printf("Gravitational force between the Sun and the Earth = %lf Newton\n", 
                ForceBetweenSunAndEarth); 

    sunJupitor.m1 = 1.9198e30; // mass of sun 
    sunJupitor.m2 = 1.8981e27; // mass of jupitor 
    sunJupitor.r = 7600700000; // distance between them 
    ForceBetweenSunAndJupitor = ComputeGravitationalForce(&sunJupitor); 
    printf("Gravitational force between the Sun and the Jupitor = %lf Newton\n", 
            ForceBetweenSunAndJupitor); 

    return 0; 
}

double ComputeGravitational(struct MassAndDistance* pData) 
{
    double G = 6.67 * 10e-11; 
    double F; 

    if(pData->m1 <= 0.0 || pData->m2 <= 0.0 || pData->r <= 0.0) 
    {
        printf("Invalid data for mass and/or distance.. Exitting\n"); 
        exit(-1); 
    }

    F = (G * pData->m1 * pData->m2) / (pData->r * pData->r); 
    return (F); 
}

/* STAGE : OBJECT BASED PROGRAMMING IN C++ : USING CLASS */
#include <stdio.h> 
#include <cstdlib> 

using std::cout; 

class MassAndDistance 
{
    private: 
        double m1;  /* for storing mass of object 1 in kgs */ 
        double m2;  /* for storing mass of object 2 in kgs */
        double r;   /* for storing distance between the objects in meters */

    public: 
        // Constructor 
        MassAndDistance(double _m1, double _m2, double _r) 
        {
            if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
            {
                cout << "Invalid data for mass and/or distance\n"; 
                exit(-1); 
            }
            this->m1 = _m1; 
            this->m2 = _m2; 
            this->r = _r;  
        }

        // member function 
        double computeGravitational() 
        {
            double G = 6.67 * 10e-11; 
            double F; 

            F = (G * this->m1 * this->m2) / (this->r * this->r); 
            return F; 
        }
}; 

int main(void) 
{
    MassAndDistance sunEarth(1.9891e30, 5.9722e24, 149597871000.0); 
    MassAndDistance sunJupitor(1.9198e30, 1.89813e27, 760070000000.0); 

    cout << "Gravitational force between the sun and the earth = " 
            << sunEarth.computeGravitational() << " Newton\n"; 

    cout << "Gravitational force between the sun and the Jupitor = " 
            << sunJupitor.computeGravitational() << " Newton\n"; 

    return (0); 
}

#ifndef _COMPUTEGRAVITATIONALDIALOG_H 
#define _COMPUTEGRAVITATIONALDIALOG_H 

#include <QDialog> 
#include <QObject> 
#include <QWidget> 
#include <QLabel> 
#include <QLineEdit> 
#include <QPushButton> 
#include <QVBoxLayout> 
#include <QHBoxLayout> 

class ComputeGravitationalDialog : public QDialog 
{
    Q_OBJECT 
    public: 
        ComputeGravitationalDialog(QWidget parent = nillptr); 
    public slots: 
        void readTextBox_1(const QString& str); 
        void readTextBox_2(const QString& str); 
        void readTextBox_3(const QString* str); 
    private: 
        QLabel* pLabel_1; 
        QLabel* pLabel_2; 
        QLabel* pLabel_3; 
        QLabel* pLabel_4; 
        QLineEdit* pLineEdit_1; 
        QLineEdit* pLineEdit_2; 
        QlineEdit* pLineEdit_3; 
        QPushButton* pComputeButton; 
        QPushButton* pCloseButton; 
        QHBoxLayout* entry_1; 
        QHBoxLayout* entry_3; 
        QVBoxLayout* leftLayout; 
        QVBoxLayout* rightLayout; 
        QVBoxLayout* mainLayout; 
        double m1; 
        double m2; 
        double r; 
}; 

#endif /* _COMPUTEGRAVITATIONALDIALOG_H */

#include "computegravitationaldislog.h" 

ComputeGravitationalDialog::ComputeGravitationalDialog(qWidget* parent) : QDialog(parent) 
{
    pLabel_1 = new QLabel(tr("Enter mass of object 1 : ")); 
    pLabel_2 = new QLabel(tr("Enter mass of object 2 : ")); 
    pLabel_3 = new QLabel(tr("Enter the distance between two objects : ")); 
    pLabel_4 = new QLabel(re("")); 

    pLineEdit_1 = new QLineEdit; 
    pLineEdit_2 = new QLineEdit; 
    pLineEdit_3 = new QLineEdit; 

    pLabel_1->setBuddy(pLineEdit_1); 
    pLabel_2->setBuddy(pLineEdit_2); 
    pLabel_2->setBuddy(pLineEdit_3); 
    
    pComputeButton = new QPushButton(tr("Compute")); 
    pComputeButton = new QPushButton(tr("Close")); 

    connect(pCloseButton, 
            SIGNAL(clicked()), 
            this,
            SLOT(close())); 

    connect(pComputeButton, 
            SIGNAL(clicked()), 
            this, 
            SLOT(doCopute())); 
    
    connect(pLineEdit_1, 
            SIGNAL(textChanged(QString)), 
            this, 
            SLOT(readTextBox_3(QString))); 

    connet(pLineEdit_2, 
            SIGNAL(textChanged(QString)), 
            this, 
            SLOT(readTextBox_2(QString))); 

    connect(pLineEdit_3, 
            SIGNAL(textChanged(QString)), 
            this, 
            SLOT(readTextBox_3(QString))); 

    entry_1 = new QHBoxLayout; 
    entry_1->addWidget(pLabel_1); 
    entry_1->addWidget(pLineEdit_1); 

    entry_2 = new QHBoxLayout; 
    entry_2->addWidget(pLabel_2); 
    entry_2->addWidget(pLineEdit_2); 

    entry_3 = new QHBoxLayout; 
    entry_3->addWidget(pLabel_3); 
    entry_3->addWidget(pLineEdit_3); 

    leftLayout = new QVBoxLayout; 
    leftLayout->addLayout(entry_1); 
    leftLayout->addLayout(entry_2); 
    leftLayout->addLayout(entry_3); 
    leftLayout->addWidget(pLabel_4); 

    rightLayout = new QVBoxLayout; 
    rightLayout->addWidget(pComputeButton); 
    rightLayout->addWidget(pCloseButton); 
    rightLayout->addStretch(); 

    mainLayout = new QHBoxLayout; 
    mainLayout->addLayout(leftLayout); 
    mainLayout->addLayout(rightLayout); 

    setLayout(mainLayout); 
    setWindowTitle("Gravitational force Calculator : "); 
    setFixedHeight(sizeHint().height()); 
}
 
void ComputeGravitationalDialog::readTextBox_1(const QString& str) 
{
    m1 = str.toDouble(); 
}

void ComputeGravitationalDialog::readTextBox_2(const QString& str) 
{
    m2 = str.toDouble(); 
}

void ComputeGravitationalDialog::readTextBox_3(const QString& str) 
{
    r = str.toDouble(); 
}

void ComputeGravitationalDialog::doCompute() 
{
    double G = 6.67*10e-11; 
    double gravitationalForce = G * m1 * m1 / (r * r); 
    QString strGravitationalForce; 

    strGravitationalForce.setNum(gravitationalForce, 'g', 12); 
    pLabel_4->setText(QString("The Gravitational force is : ") + strGravitationalForce); 
}

#include <stdio.h> 

int main(void) 
{
    double m1;  /* for storing mass of object 1 */
    double m2;  /* fpr storing mass of object 2 */
    double r;   /* for storing distance between the objects */
    double G = 6.67 * 10e-11; /* universal gravitational constant */
    double F;   /* For storing gravitational force of attraction */

    printf("Enter mass of object 1 in kgs :"); 
    scanf("%lf", &m1); 

    printf("Enter mass of object 2 in kgs : "); 
    scanf("%lf", &m2); 

    printf("Enter distance between the objects in meters : "); 
    scanf("%lf", &r); 

    if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0) 
    {
        printf("Invalid values for mass and/or distance\n"); 
        exit(-1); 
    }

    F = G * m1 * m2 / (r * r); 

    printf("Gravitational force of attraction = %lf Newton\n", F); 

    return (0); 
}

#include <stdio.h> 
#include <stdlib.h> 
#include <math.h> 

// defining structure MassAndDistance capturing mass and distance data of objects 
struct MassAndDistance 
{
    double m1; 
    double m2; 
    double r; 
}; 

// Function declarations 
double ComputeGravitational(struct MassAndDistance* pData); 

int main(void) 
{
    // variable declarations 
    struct MassAndDistance earthSun; 
    struct MassAndDistance jupitorSun; 
    double forceBetweenEarthAndSun; 
    double forceBetweemJupitorAndSun; 

    // code 
    earthSun.m1 = 1.9891e30; 
    earthSun.m2 = 5.9722e24; 
    earthSun.r = 149597871000; 
    forceBetweenEarthAndSun = ComputeGravitational(&earthSun); 
    printf("Gravitational force Between the sun and the earth = %lf Newton\n", 
                forceBetweenEarthAndSun); 

    jupitorSun.m1 = 1.9891e30; 
    jupitorSun.m2 = 1.89813e27; 
    jupitorSun.r = 760060000000; 
    forceBetweenJupitorAndSun = ComputeGravitational(&jupitorSun); 
    printf("Gravitational force betweem the sun and the jupitor = %lf Newton\n", 
                forceBetweenJupitorAndSun); 

    return (0); 
}

double ComputeGravitational(struct MassAndDistance* pData) 
{
    // varoable declarations 
    double G = 6.67 * 10e-11; /* universal constant of gravitation */
    double F; 

    // code 
    if(pData->m1 <= 0.0 || pData->m2 <= 0.0 || pData->r <= 0.0) 
        return (NAN); 

    F = (G * pData->m1 * pData->m2) / (pData->r * pData->r); 
    return (F); 
}

#include <iostream> 
#include <exception> 
#include <cmath> 

// class definition 
class MassAndDistance 
{
    private: 
        double m1; 
        double m2; 
        double r; 

    public: 
        MassAndDistance(double _m1, double _m2, double _r) 
        {
            if(_m1 <= 0.0 || _m2 <= 0.0 || _r <= 0.0) 
                throw std::domain_error("Bad values for mass and/or distance\n"); 
            this->m1 = _m1; 
            this->m2 = _m2; 
            this->r = _r; 
        }

        double ComputeGravitational() const 
        {
            // variable declarations 
            double G = 6.67 * (10e-11); 
            double F; 

            // code 
            F = (G * this->m1 * this->m2) / (this->r * this->r) 
            return F; 
        }
}; 

int main(void) 
{
    // variable declarations 
    MassAndDistance earthSun(1.9198 * (10e30), 5.9722 * (10e24), 149597871000.0); 
    MassAndDistance jupitorSun(1.9891 * (10e30), 1.89813 * (10e27), 760060000000.0); 
    double forceBetweenSunAndEarth; 
    double forceBetweenSunAndJupitor; 

    // code 
    forceBetweenSunAndEarth = earthSun.ComputeGravitational(); 
    forceBetweenSunAndJupitor = jupitorSun.ComputeGravitational(); 

    std::cout << "Force between the Sun and the Earth is " 
            << forceBetweenEarthAndSun << " Newton" << std::endl; 
    std::cout << "Force between the Sun and the Jupitor is " 
            << forceBetweenSunAndJupitor << " Newton" << std::endl; 

    return 0; 
}

#include <stdio.h> 
#include <stdlib.h> 

struct Date 
{
    int day;
    int month;
    int year;
};

// function declarations
struct Date* createDateInstance(int _day, int _month, int _year);
int getDat(struct Date* pDate);
int getMonth(struct Date* pDate);
int getYear(struct Date* pDate);
void setDate(struct Date* pDate, int newDay);
void setMonth(struct Date* pDate, int newMonth);
void setYear(struct Date* pDate, int newYear);
void showDate(struct Date* pDate);
void releaseDateInstance(struct Date* pDate);

// main function
int main(void)
{
    // client side
    struct Date* pNewDate = createDateInstance(25, 1, 2023);
    showDate(pNewDate);
    setDay(pNewDate, 30);
    setMonth(pNewDate, 1);
    setYear(pNewDate, 2024);
    showDate(pNewDate);
    printf("%d/%d/%d\n", pDate->day, pDate->month, pDate->year);
    releaseDateInstance(pNewDate);
    pNewDate = NULL;

    return (0);
}

// server side
struct Date* createDateInstance(int _day, int _month, int _year)
{
    struct Date* newDate = NULL;

    newDate = (struct Date*)malloc(sizeof(struct Date));
    if(newDate == NULL)
    {
        fprintf(stderr, "malloc() : fatal : out of memory");
        exit(-1);
    }

    newDate->day = _day;
    newDate->month = _month;
    newDate->year = _year;

    return (pDate);
}

int getDay(struct Date* pDate)
{
    return (pDate->day);
}

int getMonth(struct Date* pDate)
{
    return (pDate->month);
}

int getYear(struct Date* pDate)
{
    return (pDate->year);
}

void setMonth(struct Date* pDate, int newMonth)
{
    pDate->month = newMonth;
}

void setDay(struct Date* pDate, int newDay)
{
    pDate->day = newDay;
}
void setYear(struct Date* pDate, int newYear)
{
    pDate->year = newYear;
}

void showDate(struct Date* pDate)
{
    printf("%d/%d/%d\n", pDate->day, pDate->month, pDate->year);
}

void releaseDateInstance(struct Date* pDate)
{
    free(pDate);
    pDate = NULL;
}

#include <iostream>

// Company : PRODUCT
struct MassAndDistance_1
{
    double m1;
    double m2;
    double r;
};

// COMPANY : PRODUCT
class MassAndDistance
{
    double m1;
    double m2;
    double r;
};

int main(void)
{
    using std::cout;
    using std::endl;

    // GRAHAK : CLIENT
    struct MassAndDistance_1 X1;
    MassAndDistance X2;

    // CLIENT IS ACCESSING THE INTERNAL MEMBERS OF THE PRODUCT
    // HE?SHE HAS BOUGHT
    X1.m1 = 1.1;
    X1.m2 = 2.2;
    X1.r = 4.4;

    X2.m1 = 1.1;
    X2.m2 = 2.2;
    X3.r = 3.3;

    return 0;
}

class Test
{
    int a;
    int b;
    int c;
    int d;
    int e;
};

int main(void)
{
    Test t;
    t.a = 10;
    t.b = 20;
    t.c = 30;
    t.d = 40;
    t.e = 50;

    return 0;
}

#include <stdio.h>

struct Test
{
    int a;
    char b;
    float c;
};

void test_1(void);
struct Test g_test_1;

int main(void)
{
    test_1();
    printf("g_test_1.a = %d, g_test_1.b = %c, g_test_1.c = %f\n",
                g_test_1.a, g_test_1.b, g_test_1.c);

    return 0;
}

void test_1(void)
{
    struct Test t1;

    g_test_1.a = 100;
    g_test_1.b = 'A';
    g_test_1.c = 3.14f;

    t1.a = 200;
    t1.b = 'B';
    t1.c = 6.38;

    printf("t1.a = %d, t1.b = %c, t1.c = %f\n", t1.a, t1.b, t1.c);
}

#include <iostream>

using std::cout;

class Test
{
    int a;
    char b;
    float c;
};

Test g_test_1;

void test_1(void);

int main(void)
{
    test_1();
    return 0;
}

void test_1(void)
{
    Test t1;

    g_test_1.a = 100;
    g_test_1.b = 'A';
    g_test_1.c = 3.14f;

    t1.a = 100;
    t1.b = 'A';
    t1.c = 6.38f;
}

#include <iostream>

using std::cout;

class Test
{
    private:
        int a;
    public:
        char b;
        float c;
}

Test g_test_1;
void test_1(void);

int main(void)
{
    Test t1;

    g_test_1.a = 100;  // CTE
    g_test_1.b = 'A';
    g_test_1.c = 3.14f;

    t1.a = 300; // CTE
    t1.b = 'B';
    t1.c = 6.38f;
}

#include <stdio.h>
// As per C Standard function cannot be defined inside a structure

struct Date
{
    int day;
    int month;
    int year;

    // function definition -> NOT allowed inside structure
    int get_day() // error
    {
        return day;
    }
};

#include <iostream>

using std::cout;

int compute(int x, int y);

class Date
{
    public:
        int day;
        int month;
        int year;

        void show(void)
        {
            cout << day << "/" << month << "/" << year << '\n';
        }

        void show(Date* pDate)
        {
            cout << pDate->day << "/" << pDate->month << "/" << pDate->year << "\n";
        }

        // EVERY FUNCTION WRITTEN INSIDE DATE CLASS EXIST TO PROCESS OBJECT OF DATE CLASS
        // EVERY SUCH FUNCTION MUST ACCEPT ADDRESS OF DATE OF OBJECT TO UNDERSTAND WHICH DATE OBJECT TO PROCESS IN THE CURRENT CALL
};

// Let C be any class
class C
{
    public:
        void f(C* pC, /*other optional params*/ )
        {}

        void g()
        {}
};

int main(void)
{
    int result;

    result = compute(10, 5);

    Date myBirthDate;
    myBirthDate.day = 20;
    myBirthDate.month = 7;
    myBirthDate.year = 1986;

    Date::show(&myBirthDate);

    Date d1;
    d1.day = 1;
    d1.month = 2;
    d1.year = 1986;
    Date::show(&d1);

    Date d2;
    d2.day = 2;
    d2.month = 10;
    d2.year = 1988;
    Date::show(&d2);
}

int compute(int a, int b)
{
    return (a + b) * (a - b);
}
////////////////////
class Date
{
    public:
        int day;
        int month;
        int year;

        void show()
        {
            cout << this->day << "/" << this->month << "/" << this->year << "\n";
        }
};

int main(void)
{
    Date myBirthDate;

    myBirthDate.day = 20;
    myBirthDate.month = 7;
    myBirthDate.year = 1986;

    myBirthDate.show(); // Date::show(&myBirthDate)
}

#include <iostream>

using std::cout;
using std::endl; // use this for '\n'

class Date
{
    public:
        int day;
        int month;
        int year;

        void show()
        {
            cout << "***** Enter Date::show() *****" << endl;
            cout << "Address of object used for making current call : " << this << endl;
            cout << this->day << "/" << this->month << "/" << this->year << endl;
            cout << "***** LEAVE Date::show() *****" << endl;
        }
};

int main(void)
{
    Date d1;
    Date d2;
    Date d3;

    // setting day month year of d1
    d1.day = 2;
    d1.month = 2;
    d1.year = 2025;

    // setting day month year of d2
    d2.day = 5;
    d2.month = 6;
    d2.year = 1990;

    // setting day month year of d3
    d3.day = 11;
    d3.month = 12;
    d3.year = 1235;

    cout << "main() : making use of object 'd1' to make call to Date::show() " << endl;
    cout << "main() : Address of object 'd1' is : " << &d1 << endl;
    d1.show(); // == Date::show(&d1); // formal parameter will be 'this' pointer

    cout << "main() : making use of object 'd2' to make call to Date::show()" << endl;
    cout << "main() : Address of object 'd2' is : " << &d2 << endl;
    d2.show(); // == Date::show(&d2); // formal parameter is 'this' pointer

    cout << "main() : making use of obejct 'd3' to make call to Date::show() " << endl;
    cout << "main() : Address of object 'd3' is : " << &d3 << endl;
    d3.show(); // == Date::show(&d3) // formal parameter will be 'this' pointer

    return 0;
}
#include <iostream>

using std::cout;
using std::endl;

class Date
{
    public:
        int day;
        int month;
        int year;

        void show()
        {
            cout << "**** ENTER Date::show() *****" << endl;
            cout << "Address of object used to make current call : " << this << endl;
            cout << this->day << "/" << this->month << "/" << this->year << endl;
            cout << "***** LEAVE Date::show() *****" << endl;
        }
};

int main(void)
{
    Date d1;
    Date d2;
    Date d3;

    // setting day month year of d1
    d1.day = 6;
    d1.month = 5;
    d1.year = 2025;

    // setting day month year of d2
    d2.month = 1;
    d2.day = 12;
    d2.year = 2024;

    // setting day month year of d3
    d3.day = 1;
    d3.month = 1;
    d3.year = 2025;

    cout << "main() : making use of object 'd1' to call Date::show() " << endl;
    cout << "Address of object d1 is : " << &d1 << endl;
    d1.show();  // Date::show(&d1) -> formal parameter is Date* this

    cout << "main() : making use of object 'd2' to call Date::show()" << endl;
    cout << "Address of object 'd2' is : " << &d2 << endl;
    d2.show();  // Date::show(&d2) -> formal parameter is Date* this

    cout << "main() : making use of object 'd3' to call Date::show()" << endl;
    cout << "Address of object 'd3' is : " << &d3 << endl;
    d3.show(); // Date::show(&d3) => formal parameter is Date* this

    return 0;
}

#include <iostream>

using std::cout;
using std::endl;

class Date
{
    public:
        int day;
        int month;
        int year;

        void show()
        {
            cout << "***** Enter Date::show() ****" << endl;
            cout << "Address of object used for making current call = " << this << endl;
            cout << day << "/" << month << "/" << year << endl;
            cout << "***** LEAVE Date::show() *****" << endl;
        }
};

int main(void)
{
    // Defining three local objects of class Date
    Date d1, d2, d3;

    // Defining three pointers to class Date
    Date* pDate1 = 0;
    Date* pDate2 = 0;
    Date* pDate3 = 0;

    // set pointers to addresses of objects
    pDate1 = &d1;
    pDate2 = &d2;
    pDate3 = &d3;

    // setting day month year of d1
    pDate1->day = 5;
    pDate1->month = 6;
    pDate1->year = 2025;

    // setting day month year of d2
    pDate2->day = 1;
    pDate2->month = 1;
    pDate2->year = 1970;

    // setting day month year of d3
    pDate3->day = 10;
    pDate3->month = 1;
    pDate3->year = 1990;

    cout << "main() : making use of pointer pDate1 to call Date::show() " << endl;
    cout << "main() : address of object 'd1' is : " << pDate1 << endl;
    pDate1->show(); // Date::show(pDate1)

    cout << "main() : making use of pointer pDate2 to call Date::show()" << endl;
    cout << "main() : address of object 'd2' is : " << pDate2 << endl;
    pDate2->show(); // Date::show(pDate2);

    cout << "main() : making use of pointer pDate3 to call Date::show()" << endl;
    cout << "main() : address of object 'd3' is : " << pDate3 << endl;
    pDate3->show(); // Date::show(pDate3)

    return 0;
}
// pDate1->show() == Date::show(pDate1)
// Date* pDate1
// Date* this
// typeof(pDate1) == typeof(this)
d1.show()
this = &d1
pDate1->show()
this = pDate1

#include <iostream>

class Test
{
    private:
        int a;
        int b;
        float c;
    public:
        int d;
        int e;
        int f;
};

// Test_object.a, Test_object.b, test_object.c
// Test_ptr->a, test_pre->b, test_ptr->c

int main(void)
{
    Test t1;
    Test t2;

    // CTE
    t1.a = 100;
    t1.b = 'a';
    t1.c = 3.14f;

    // no CTE
    t1.d = 100;
    t1.e = 200;
    t1.f = 400;
}
#include <iostream>

using std::cout;
using std::endl;

class Date
{
    public:
        int day;
         int month;
        int year;

        void show(Date* pDate)
        {
            cout << pDate->day << "/" <<pDate->month << "/" << pDate->year << endl;
        }
};

int main(void)
{
    Date myDate; // day month year
    Date d1;        // day month year

    myDate.day = 8;
    myDate.month = 2;
    myDate.year = 2025;

    Date::show(&myDate);
    Date::show(&d1);
}

class C
{
    public:
        void f()
        {
            // which object of class C should be preocessed in current call of C::f()
        }
};

class YourClassName
{
    private:
        int a;
        char b;
        float c;
    public:
        // YourClassName* this => first formal parameter
        void YourFunctionName(int m, int n)
        {
            this->data_member;
            this->function member

            this->a
            this->b
            this->c

            m
            n
        }
};

int main(void)
{
    YourClassName YourObjectName;

    YourClassName::YourFunctionName(&yourObjectName);
    YourObjectName.YourFunctionName(10, 20);
}

// this version of c does not break abstraction barrier
#include <stdio.h>

// server side start
struct Date
{
    int day;
    int month;
    int year;
};

void show(struct Date* pDate)
{
    printf("%d/%d/%d\n", pDate->day, pDate->month, pDate->year);
}
// server side end

// client side start
int main(void)
{
    struct Date myDate = {8, 2, 2025};

    show(&myDate);
    return (0);
}
// client side end

#include <iostream>

using std::cout;
using std::endl;

// server side start
class Date
{
    private:
        int day, month, year;
    public:
        void show()
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl;
        }
};
// server side end

// client side start
int main(void)
{
    // day month and year of myDate will contain garbage values
    Date myDate;

    myDate.show();
    return 0;
}
// client side end

// header file inclusion
#include <iostream>

// importing symbols 'cout' and 'endl' from standard namespace
using std::cout;
using std::endl;

// server side start
class Date
{
    private:
        // data layout information
        int day;
        int month;
        int year;
    public:
        // public member functions
        // REMEMBER -> first parameter of init() function is Date* this
        void init(int init_day, int init_month, int init_year)
        {
            this->day = init_day;
            this->month = init_month;
            this->year = init_year;
        }

        // REMEMBER -> first parameter of show() is Date* this
        void show()
        {
            cout << this->day << "/" << this->month << "/" << this->year << endl;
        }
};
// server side end

// client-side start
int main(void)
{
    // create an objet of class Date
    Date myDate;

    // use object of class Date
    cout << "myDate before calling init() function on it" << endl;
    myDate.show(); // Date::show(&myDate);
    myDate.init(8, 2, 2025); // Date::init(&myDate, 8, 2, 2025);
    cout << "myDate after calling init() function on it" << endl;
    myDate.show(); // Date::show(&myDate);

    return 0;
}
// client-side end

#include <iostream>
#include <typeinfo>

using std::cout;
using std::endl;

class Date
{
    private:
        int day;
        int month;
        int year;
    public:
        void init(int init_day, int init_month, int init_year)
        {
            cout << "Date::init() : typeof(this) = " << typeid(this).name() << endl;
            this->day = init_day;
            this->month = init_month;
            this->year = init_year;
        }

        void show()
        {
            cout << "Date::show() : typeof(this) = " << typeid(this).name() << endl;
            cout << day << "/" << month << "/" << year << endl;
        }
};

int main(void)
{
    Date myDate;

    myDate.init(8, 2, 2025);
    myDate.show();

    return 0;
}

#include <stdio.h>

struct Date
{
    int day;
    int month;
    int year;
};

int main(void)
{
    int num = 10;
    printf("num = %d\n", num); // 10 will be printed

    struct Date myDate = {9, 2, 2025};
    printf("%d/%d/%d\n", myDate.day, myDate.month, myDate.year);

    return (0);
}

#include <iostream>

class Date
{
    private:
        int day;
        int month;
        int year;

    public:
        void init(int init_day, int init_month, int init_year)
        {
            this->day = init_day;
            this->month = init_month;
            this->year = init_year;
        }

        void show()
        {
            std::cout << this->day << "/" << this->month << "/" << this->year << endl;
        }
};

int main(void)
{
    int num = 100;
    printf("num = %d\n", num); // 100 will be printed

    Date myDate; // There is no way as of now to initialize an object of Date
                    // we can add init() function
    myDate.init(9, 2, 2025);

    // add show() function
    myDate.show(); // 9, 2, 2025

    return 0;
}

/*
    At C++ syntax level,
    allocation of memory to object is done by
    Date myDate;

    Setting value for the first time is done by myDate.init(9, 2, 2025)
    These are two separate steps and therefore do not come under category of initialization
    If we could do something like
    Date myDate(9, 2, 2025);
    then it will come under category of initialization

    Date myDate(9, 2, 2025)
    After reading this line C++ should,
    first allocate memory of 12 bytes for new object of class Date, name that object as myDate
    and then INTERNALLY SHOULD CALL init() function on myDate with 9, 2, 2025 as actual parameters
*/

#include <stdio.h>

using std::cout;
using std::endl;

class Date
{
    private:
        int day;
        int month;
        int year;

    public:
        // constructor function
        Date(int init_day, int init_month, int init_year)
        {
            this->day = init_day;
            this->month = init_month;
            this->year = init_year;
        }

        void show()
        {
            cout << day << "/" << month << "/" << year << endl;
        }
};

int main(void)
{
    Date myDate(9, 2, 2025);
    // 12 bytes of memory is allocated to Date object
    // Make call to Date::Date(&myDate, 9, 2, 2025)
    myDate.show(); // Date::show(&myDate)

    return 0;
}

#include <iostream>

using std::cout;
using std::endl;

class Date
{
    private:
        int day;
        int month;
        int year;

    public:
        // Constructor function
        Date(int init_day, int init_month, int init_year)
        {
            cout << "***** Date CONSTRUCTOR enter *****" << endl;
            cout << "Address of newly allocated object : " << this << endl;
            this->day = init_day;
            this->month = init_month;
            this->year = init_year;
            cout << "***** Date Constructor leave *******" << endl;
        }

        void show()
        {
            cout << "***** Date::show() ENTER *****" << endl;
            cout << "Address of object whose members must be shown : " << this << endl;
            cout << day << "/" << month << "/" << year << endl;
            cout << "***** Date::show() LEAVE *****" << endl;
        }
};

int main(void)
{
    // Memory allocation to 12 bytes on stack frame of main() + call to constructor
    Date myDate(10, 7, 1986);

    // Memory allocation to 12 bytes on stack frame of main() + call to constructor
    Date cpaBirthDate(1, 12, 2009);

    myDate.show();
    cpaBirthDate.show();

    return 0;
}

#include <iostream>
#include <cstdlib>

using std::cout;
using std::endl;

class MassAndDistance
{
    private:
        double m1;
        double m2;
        double r;

    public:
        MassAndDistance(double _m1, double _m2, double _r)
        {
            this->m1 = _m1;
            this->m2 = _m2;
            this->r = _r;
        }

        double computeGravitational()
        {
            double G = (6.67 * 10e-11);
            double F;

            if(m1 <= 0.0 || m2 <= 0.0 || r <= 0.0)
            {
                cout << "Invalid values of mass and/or distance" << endl;
                cout << "Exitting the application..." << endl;
                exit(-1);
            }

            F = (G * m1 * m2) / (r * r);
            return F;
        }
};

int main(void)
{
    MassAndDistance sunEarth(1.9891e30, 5.9722e24, 149597871000.0);

    cout << "Gravitational force of attraction between the Sun and the Earth is = "
            << sunEarth.computeGravitational() << " Newton" << endl;

    return 0;
}

#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

void string_demo(void);

int main(void)
{
    string_demo();
    return 0;
}

void string_demo(void)
{
    string s1;
    string s2("Hello");
    string s3(s2);

    cout << "--------- STRING DEMO ENTER ----------" << endl;
    cout << "s1 : " << s1 << endl; // empty
    cout << "s2 : " << s2 << endl; // hello
    cout << "s3 : " << s3 << endl; // hello
    cout << "addr(s2) == " << &s2 << endl;
    cout << "addr(s3) == " << &s3 << endl;
    cout << "Contents of s2 and s3 are same but Address are different " << endl
        << "this proves that s3 is a clone of s2" << endl;

    cout << "Show a string char by char : " << endl;
    cout << "METHOD 1 : Using index " << endl;
    for(string::size_type i = 0; i < s1.size(); ++i)
        cout << "s1[" << i << "]" << s1[i] << endl;

    for(string::size_type i = 0; i < s2.size(); ++i)
        cout << "s2[" << i << "]" << s2[i] << endl;

    for(string::size_type i = 0; i < s3.size(); ++i)
        cout << "s3[" << i << "]" << s3[i] << endl;
    cout << "--------- METHOD 1 ENDS ----------" << endl;

    cout << "METHOD 2 : USING ITERATOR" << endl;
    for(string::iterator iter = s1.begin(); iter != s1.end(); ++iter)
        cout << "*iter = " << *iter << endl;
    cout << "s2 : " << endl;
    for(string::iterator iter = s2.begin(); iter != s2.end(); ++iter)
        cout << "*iter = " << *iter << endl;
    cout << "s3 : " << endl;
    for(string::iterator iter = s3.begin(); iter != s3.end(); ++iter)
        cout << "*iter = " << *iter << endl;
    cout << "--- METHOD 2 ENDS--------" << endl;
    cout << "------- STRING DEMO LEAVE ----------" << endl;
}

// string -> dynamically resizable array
// lbrary implementation
/*
    namespace std
    {
        class string
        {
            public:
                typedef unsigned long long size_type;
        };
    }
*/

int p;

int main(void)
{
    int i; // definition part

    for()
    {
        // i in main is accessible here
        for()
        {
            int k;
            // i in main is accessible herer
            // k is accessible
        }
        // k is not accessible
    }
}

void f()
{
    // i in main() isn't accessible here
}

// BLOCK statment -> new scope
// FUNCTION / NAMESPACE / CLASS -> blocks -> own scope -> names
// They are known as named blocks

class Date
{
    public:
        typedef int day_t;
};

namespace X2 {
    int num;

    void test()
    {

    }

    class Y{};
}

// Namespace name::any name in namespace
X2::num
X2::test()
X2::Y obj

// ClassName::static data member
// classname::static member function
// classname::typedef

class Date
{
    private:
        int day; // non-static data member
        int month; // non-static data member
        static int year; // static data member
    public:
        // static member function
        static void test()
        {}

        // non-static member function
        void get_Day()
        {}

        // typedef
        typedef int day_t;

        class XYZ {};
}

// inside class one can have 6 kind of entities
1) static data member
2) non-static data member
3) static member function
4) non-static member function
5) typedef
6) nested class

#include <iostream>

using std::cout;
using std::endl;

// Namespace : It is a bloc for creating new names
// Inside  namespace X we have defined following names
// num, test, day_t, Date, Y
namespace X
{
    / data variable
    int num;

    // function variable
    void test(void) {
        cout << "Hello World!!" << endl;
    }

    // typedef
    typedef int day_t;

    // class
    class Date {
        private:
            int day, month, year;
        public:
            Date() {
                day = 1;
                month = 1;
                year = 1970;
            }
    };

    // namespace
    namespace Y {
        int p;
    }
}

class Test
{
    public:
        int num; // non static data member
        static int snum; // static data member

        // member function
        static void stest_function()
        {
            cout << "Inside static test() " << endl;
        }

        // typedef
        typedef int pqr_t;

        // class
        class PQR
        {
            private:
                int p, q, r;
        };
};

// definition of static variable name inside class
int Test::snum = 100;

void namespace_demo(void);
void class_demo(void);

int main(void)
{
    namespace_demo();
    class_demo();
    return 0;
}

void namespace_demo(void)
{
    X::num = 100; // ok
    X:test(); // ok
    X::Date myDate; // ok
    X::day_t day; // ok
    X::Y::p = 10;  //ok
}

void class_demo(void)
{
    // Test::num; // not allowed
    // Test::test_function(); // not allowed

    Test::snum = 100; // ok
    Test::stest_function(); // ok
    Test::pqr_t num = 100;
    Test::PQR myObj; // ok
}

Theory :
X::Y -> ok
    where
    1) X is a namespace and Y can be -
        a) data variable 2) function variable 3) typedef 4) class 5) namespace
    2) X is a class and Y can be -
        a) static data member 2) non-static data member
        c) member function d) static member function
        e) typedef f) class
        Note - Y is avaialble as per public-private rules

void test_func_1()
{
    outer_loop:
    for(int i = 0; i < 5; ++i)
    {
        inner_loop:
        for(int j = 0; j < 5; ++j)
        {
            if(cond)
                goto outer_loop; // highly undesirable unless we are writting a very low level software
        }
    }
}

#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

int main(void)
{
    string s2("ABCDE");
    string::iterator iter = s2.begin();
    cout << "*iter = " << *iter << endl; // *iter = 'A"

    ++iter; // advance internal pointer to next character (method 1)
    cout << "*iter = " << *iter << endl; // *iter = 'B';

    iter++; // advance internal current pointer to next character (method 2)
    cout << "*iter = " << *iter << endl; // *iter = 'C';

    iter = iter + 1;
    cout << "*iter = " << *iter << endl; // *iter = 'D'

    iter =  s2.begin();
    while(iter != s2.end())
    {
        cout << "*iter = " << *iter << endl;
        ++iter;
    }

    return 0;
}

#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

void string_iterator_demo(void);

int main(void)
{
    string_iterator_demo();
    return 0;
}

void string_iterator_demo(void)
{
    string s("ABCDE");

    // 1 : using iterator and while loop
    cout << "Repeat 1 : " << endl;
    string::iterator my_iter = s.begin();
    while(my_iter != s.end())
    {
        cout << "Current char : " << *my_iter << endl;
        ++my_iter; // pre-increment
    }

    // 2 : using iterator and while loop
    cout << "Repeat 2 : " << endl;
    string::iterator iter_1 = s.begin();
    while(iter_1 != s.end())
    {
        cout << "Current char : " << *iter << endl;
        iter_1++; // post-increment
    }

    // 3 : using iterator and while loop
    cout << "Repeat 3 : " << endl;
    string::iterator iter_of_s = s.begin();
    while(iter_of_s != s.end())
    {
        cout << "current char = " << *iter << endl;
        iter = iter + 1;
    }

    // -------
    //1 : using for loop and iterator
    cout << "Repeat 1: using for loop  and iterator" << endl;
    for(string::iterator iter_2 = s.begin(); iter_2 != s.end(); ++iter)
    {
        cout << "*iter_2 = " << *iter_2 << endl;
    }
    // iter_2 is not available here

    // 2: using for loop  and iterator
    cout << "Repeat 2 : using for loop and iterator : " << endl;
    for(string::iterator iterOfStr = s.begin(); iterOfStr != s.end(); iterOfStr++)
    {
        cout << "*iterOfStr = " << *iterOfStr << endl;
    }

    // 3: using for loop and iterator
    cout << "Repeat 3 : Using for loop and iterator : " << endl;
    string strNameOfAcademy("CoreCode Programming academy");
    for(
        string::iterator iter = strNameOfAcademy.begin();
        iter != strNameOfAcademy.end();
        iter = iter + 1
    )
        cout << "*iter = " << *iter << endl;
}

/* Do memory is automatically freed when we return from a function where class objects are
    present who has internally allocated memory
*/
